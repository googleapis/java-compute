/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/compute/v1/compute.proto

package com.google.cloud.compute.v1;

/**
 *
 *
 * <pre>
 * A network peering attached to a network resource. The message includes the peering name, peer network, peering state, and a flag indicating whether Google Compute Engine should automatically create routes for the peering.
 * </pre>
 *
 * Protobuf type {@code google.cloud.compute.v1.NetworkPeering}
 */
public final class NetworkPeering extends com.google.protobuf.GeneratedMessageV3
    implements
    // @@protoc_insertion_point(message_implements:google.cloud.compute.v1.NetworkPeering)
    NetworkPeeringOrBuilder {
  private static final long serialVersionUID = 0L;
  // Use NetworkPeering.newBuilder() to construct.
  private NetworkPeering(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }

  private NetworkPeering() {
    name_ = "";
    network_ = "";
    state_ = 0;
    stateDetails_ = "";
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
    return new NetworkPeering();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
  }

  private NetworkPeering(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 26989658:
            {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
          case 115357832:
            {
              importSubnetRoutesWithPublicIp_ = input.readBool();
              break;
            }
          case 210578048:
            {
              exchangeSubnetRoutes_ = input.readBool();
              break;
            }
          case 459639528:
            {
              autoCreateRoutes_ = input.readBool();
              break;
            }
          case 482251880:
            {
              exportCustomRoutes_ = input.readBool();
              break;
            }
          case 556677768:
            {
              peerMtu_ = input.readInt32();
              break;
            }
          case 764535970:
            {
              java.lang.String s = input.readStringRequireUtf8();

              stateDetails_ = s;
              break;
            }
          case 783526672:
            {
              exportSubnetRoutesWithPublicIp_ = input.readBool();
              break;
            }
          case 878060680:
            {
              int rawValue = input.readEnum();

              state_ = rawValue;
              break;
            }
          case 1583859184:
            {
              importCustomRoutes_ = input.readBool();
              break;
            }
          case 1862979954:
            {
              java.lang.String s = input.readStringRequireUtf8();

              network_ = s;
              break;
            }
          default:
            {
              if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
    } finally {
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }

  public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_NetworkPeering_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_NetworkPeering_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.google.cloud.compute.v1.NetworkPeering.class,
            com.google.cloud.compute.v1.NetworkPeering.Builder.class);
  }

  /**
   *
   *
   * <pre>
   * [Output Only] State for the peering, either `ACTIVE` or `INACTIVE`. The peering is `ACTIVE` when there's a matching configuration in the peer network.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.NetworkPeering.State}
   */
  public enum State implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_STATE = 0;</code>
     */
    UNDEFINED_STATE(0),
    /** <code>ACTIVE = 46297862;</code> */
    ACTIVE(46297862),
    /** <code>INACTIVE = 1985643;</code> */
    INACTIVE(1985643),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_STATE = 0;</code>
     */
    public static final int UNDEFINED_STATE_VALUE = 0;
    /** <code>ACTIVE = 46297862;</code> */
    public static final int ACTIVE_VALUE = 46297862;
    /** <code>INACTIVE = 1985643;</code> */
    public static final int INACTIVE_VALUE = 1985643;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static State valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static State forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_STATE;
        case 46297862:
          return ACTIVE;
        case 1985643:
          return INACTIVE;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<State> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<State> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<State>() {
          public State findValueByNumber(int number) {
            return State.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.NetworkPeering.getDescriptor().getEnumTypes().get(0);
    }

    private static final State[] VALUES = values();

    public static State valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private State(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.NetworkPeering.State)
  }

  public static final int AUTO_CREATE_ROUTES_FIELD_NUMBER = 57454941;
  private boolean autoCreateRoutes_;
  /**
   *
   *
   * <pre>
   * This field will be deprecated soon. Use the exchange_subnet_routes field instead. Indicates whether full mesh connectivity is created and managed automatically between peered networks. Currently this field should always be true since Google Compute Engine will automatically create and manage subnetwork routes between two networks when peering state is ACTIVE.
   * </pre>
   *
   * <code>bool auto_create_routes = 57454941;</code>
   *
   * @return The autoCreateRoutes.
   */
  @java.lang.Override
  public boolean getAutoCreateRoutes() {
    return autoCreateRoutes_;
  }

  public static final int EXCHANGE_SUBNET_ROUTES_FIELD_NUMBER = 26322256;
  private boolean exchangeSubnetRoutes_;
  /**
   *
   *
   * <pre>
   * Indicates whether full mesh connectivity is created and managed automatically between peered networks. Currently this field should always be true since Google Compute Engine will automatically create and manage subnetwork routes between two networks when peering state is ACTIVE.
   * </pre>
   *
   * <code>bool exchange_subnet_routes = 26322256;</code>
   *
   * @return The exchangeSubnetRoutes.
   */
  @java.lang.Override
  public boolean getExchangeSubnetRoutes() {
    return exchangeSubnetRoutes_;
  }

  public static final int EXPORT_CUSTOM_ROUTES_FIELD_NUMBER = 60281485;
  private boolean exportCustomRoutes_;
  /**
   *
   *
   * <pre>
   * Whether to export the custom routes to peer network.
   * </pre>
   *
   * <code>bool export_custom_routes = 60281485;</code>
   *
   * @return The exportCustomRoutes.
   */
  @java.lang.Override
  public boolean getExportCustomRoutes() {
    return exportCustomRoutes_;
  }

  public static final int EXPORT_SUBNET_ROUTES_WITH_PUBLIC_IP_FIELD_NUMBER = 97940834;
  private boolean exportSubnetRoutesWithPublicIp_;
  /**
   *
   *
   * <pre>
   * Whether subnet routes with public IP range are exported. The default value is true, all subnet routes are exported. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always exported to peers and are not controlled by this field.
   * </pre>
   *
   * <code>bool export_subnet_routes_with_public_ip = 97940834;</code>
   *
   * @return The exportSubnetRoutesWithPublicIp.
   */
  @java.lang.Override
  public boolean getExportSubnetRoutesWithPublicIp() {
    return exportSubnetRoutesWithPublicIp_;
  }

  public static final int IMPORT_CUSTOM_ROUTES_FIELD_NUMBER = 197982398;
  private boolean importCustomRoutes_;
  /**
   *
   *
   * <pre>
   * Whether to import the custom routes from peer network.
   * </pre>
   *
   * <code>bool import_custom_routes = 197982398;</code>
   *
   * @return The importCustomRoutes.
   */
  @java.lang.Override
  public boolean getImportCustomRoutes() {
    return importCustomRoutes_;
  }

  public static final int IMPORT_SUBNET_ROUTES_WITH_PUBLIC_IP_FIELD_NUMBER = 14419729;
  private boolean importSubnetRoutesWithPublicIp_;
  /**
   *
   *
   * <pre>
   * Whether subnet routes with public IP range are imported. The default value is false. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always imported from peers and are not controlled by this field.
   * </pre>
   *
   * <code>bool import_subnet_routes_with_public_ip = 14419729;</code>
   *
   * @return The importSubnetRoutesWithPublicIp.
   */
  @java.lang.Override
  public boolean getImportSubnetRoutesWithPublicIp() {
    return importSubnetRoutesWithPublicIp_;
  }

  public static final int NAME_FIELD_NUMBER = 3373707;
  private volatile java.lang.Object name_;
  /**
   *
   *
   * <pre>
   * Name of this peering. Provided by the client when the peering is created. The name must comply with RFC1035. Specifically, the name must be 1-63 characters long and match regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase letter, and all the following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
   * </pre>
   *
   * <code>string name = 3373707;</code>
   *
   * @return The name.
   */
  @java.lang.Override
  public java.lang.String getName() {
    java.lang.Object ref = name_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      name_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Name of this peering. Provided by the client when the peering is created. The name must comply with RFC1035. Specifically, the name must be 1-63 characters long and match regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase letter, and all the following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
   * </pre>
   *
   * <code>string name = 3373707;</code>
   *
   * @return The bytes for name.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getNameBytes() {
    java.lang.Object ref = name_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      name_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int NETWORK_FIELD_NUMBER = 232872494;
  private volatile java.lang.Object network_;
  /**
   *
   *
   * <pre>
   * The URL of the peer network. It can be either full URL or partial URL. The peer network may belong to a different project. If the partial URL does not contain project, it is assumed that the peer network is in the same project as the current network.
   * </pre>
   *
   * <code>string network = 232872494;</code>
   *
   * @return The network.
   */
  @java.lang.Override
  public java.lang.String getNetwork() {
    java.lang.Object ref = network_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      network_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * The URL of the peer network. It can be either full URL or partial URL. The peer network may belong to a different project. If the partial URL does not contain project, it is assumed that the peer network is in the same project as the current network.
   * </pre>
   *
   * <code>string network = 232872494;</code>
   *
   * @return The bytes for network.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getNetworkBytes() {
    java.lang.Object ref = network_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      network_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int PEER_MTU_FIELD_NUMBER = 69584721;
  private int peerMtu_;
  /**
   *
   *
   * <pre>
   * Maximum Transmission Unit in bytes.
   * </pre>
   *
   * <code>int32 peer_mtu = 69584721;</code>
   *
   * @return The peerMtu.
   */
  @java.lang.Override
  public int getPeerMtu() {
    return peerMtu_;
  }

  public static final int STATE_FIELD_NUMBER = 109757585;
  private int state_;
  /**
   *
   *
   * <pre>
   * [Output Only] State for the peering, either `ACTIVE` or `INACTIVE`. The peering is `ACTIVE` when there's a matching configuration in the peer network.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.NetworkPeering.State state = 109757585;</code>
   *
   * @return The enum numeric value on the wire for state.
   */
  @java.lang.Override
  public int getStateValue() {
    return state_;
  }
  /**
   *
   *
   * <pre>
   * [Output Only] State for the peering, either `ACTIVE` or `INACTIVE`. The peering is `ACTIVE` when there's a matching configuration in the peer network.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.NetworkPeering.State state = 109757585;</code>
   *
   * @return The state.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.NetworkPeering.State getState() {
    @SuppressWarnings("deprecation")
    com.google.cloud.compute.v1.NetworkPeering.State result =
        com.google.cloud.compute.v1.NetworkPeering.State.valueOf(state_);
    return result == null ? com.google.cloud.compute.v1.NetworkPeering.State.UNRECOGNIZED : result;
  }

  public static final int STATE_DETAILS_FIELD_NUMBER = 95566996;
  private volatile java.lang.Object stateDetails_;
  /**
   *
   *
   * <pre>
   * [Output Only] Details about the current state of the peering.
   * </pre>
   *
   * <code>string state_details = 95566996;</code>
   *
   * @return The stateDetails.
   */
  @java.lang.Override
  public java.lang.String getStateDetails() {
    java.lang.Object ref = stateDetails_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      stateDetails_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * [Output Only] Details about the current state of the peering.
   * </pre>
   *
   * <code>string state_details = 95566996;</code>
   *
   * @return The bytes for stateDetails.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getStateDetailsBytes() {
    java.lang.Object ref = stateDetails_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      stateDetails_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  private byte memoizedIsInitialized = -1;

  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    if (!getNameBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3373707, name_);
    }
    if (importSubnetRoutesWithPublicIp_ != false) {
      output.writeBool(14419729, importSubnetRoutesWithPublicIp_);
    }
    if (exchangeSubnetRoutes_ != false) {
      output.writeBool(26322256, exchangeSubnetRoutes_);
    }
    if (autoCreateRoutes_ != false) {
      output.writeBool(57454941, autoCreateRoutes_);
    }
    if (exportCustomRoutes_ != false) {
      output.writeBool(60281485, exportCustomRoutes_);
    }
    if (peerMtu_ != 0) {
      output.writeInt32(69584721, peerMtu_);
    }
    if (!getStateDetailsBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 95566996, stateDetails_);
    }
    if (exportSubnetRoutesWithPublicIp_ != false) {
      output.writeBool(97940834, exportSubnetRoutesWithPublicIp_);
    }
    if (state_ != com.google.cloud.compute.v1.NetworkPeering.State.UNDEFINED_STATE.getNumber()) {
      output.writeEnum(109757585, state_);
    }
    if (importCustomRoutes_ != false) {
      output.writeBool(197982398, importCustomRoutes_);
    }
    if (!getNetworkBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 232872494, network_);
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (!getNameBytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3373707, name_);
    }
    if (importSubnetRoutesWithPublicIp_ != false) {
      size +=
          com.google.protobuf.CodedOutputStream.computeBoolSize(
              14419729, importSubnetRoutesWithPublicIp_);
    }
    if (exchangeSubnetRoutes_ != false) {
      size +=
          com.google.protobuf.CodedOutputStream.computeBoolSize(26322256, exchangeSubnetRoutes_);
    }
    if (autoCreateRoutes_ != false) {
      size += com.google.protobuf.CodedOutputStream.computeBoolSize(57454941, autoCreateRoutes_);
    }
    if (exportCustomRoutes_ != false) {
      size += com.google.protobuf.CodedOutputStream.computeBoolSize(60281485, exportCustomRoutes_);
    }
    if (peerMtu_ != 0) {
      size += com.google.protobuf.CodedOutputStream.computeInt32Size(69584721, peerMtu_);
    }
    if (!getStateDetailsBytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(95566996, stateDetails_);
    }
    if (exportSubnetRoutesWithPublicIp_ != false) {
      size +=
          com.google.protobuf.CodedOutputStream.computeBoolSize(
              97940834, exportSubnetRoutesWithPublicIp_);
    }
    if (state_ != com.google.cloud.compute.v1.NetworkPeering.State.UNDEFINED_STATE.getNumber()) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(109757585, state_);
    }
    if (importCustomRoutes_ != false) {
      size += com.google.protobuf.CodedOutputStream.computeBoolSize(197982398, importCustomRoutes_);
    }
    if (!getNetworkBytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(232872494, network_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof com.google.cloud.compute.v1.NetworkPeering)) {
      return super.equals(obj);
    }
    com.google.cloud.compute.v1.NetworkPeering other =
        (com.google.cloud.compute.v1.NetworkPeering) obj;

    if (getAutoCreateRoutes() != other.getAutoCreateRoutes()) return false;
    if (getExchangeSubnetRoutes() != other.getExchangeSubnetRoutes()) return false;
    if (getExportCustomRoutes() != other.getExportCustomRoutes()) return false;
    if (getExportSubnetRoutesWithPublicIp() != other.getExportSubnetRoutesWithPublicIp())
      return false;
    if (getImportCustomRoutes() != other.getImportCustomRoutes()) return false;
    if (getImportSubnetRoutesWithPublicIp() != other.getImportSubnetRoutesWithPublicIp())
      return false;
    if (!getName().equals(other.getName())) return false;
    if (!getNetwork().equals(other.getNetwork())) return false;
    if (getPeerMtu() != other.getPeerMtu()) return false;
    if (state_ != other.state_) return false;
    if (!getStateDetails().equals(other.getStateDetails())) return false;
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    hash = (37 * hash) + AUTO_CREATE_ROUTES_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getAutoCreateRoutes());
    hash = (37 * hash) + EXCHANGE_SUBNET_ROUTES_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getExchangeSubnetRoutes());
    hash = (37 * hash) + EXPORT_CUSTOM_ROUTES_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getExportCustomRoutes());
    hash = (37 * hash) + EXPORT_SUBNET_ROUTES_WITH_PUBLIC_IP_FIELD_NUMBER;
    hash =
        (53 * hash) + com.google.protobuf.Internal.hashBoolean(getExportSubnetRoutesWithPublicIp());
    hash = (37 * hash) + IMPORT_CUSTOM_ROUTES_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getImportCustomRoutes());
    hash = (37 * hash) + IMPORT_SUBNET_ROUTES_WITH_PUBLIC_IP_FIELD_NUMBER;
    hash =
        (53 * hash) + com.google.protobuf.Internal.hashBoolean(getImportSubnetRoutesWithPublicIp());
    hash = (37 * hash) + NAME_FIELD_NUMBER;
    hash = (53 * hash) + getName().hashCode();
    hash = (37 * hash) + NETWORK_FIELD_NUMBER;
    hash = (53 * hash) + getNetwork().hashCode();
    hash = (37 * hash) + PEER_MTU_FIELD_NUMBER;
    hash = (53 * hash) + getPeerMtu();
    hash = (37 * hash) + STATE_FIELD_NUMBER;
    hash = (53 * hash) + state_;
    hash = (37 * hash) + STATE_DETAILS_FIELD_NUMBER;
    hash = (53 * hash) + getStateDetails().hashCode();
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.google.cloud.compute.v1.NetworkPeering parseFrom(java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.NetworkPeering parseFrom(
      java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.NetworkPeering parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.NetworkPeering parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.NetworkPeering parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.NetworkPeering parseFrom(
      byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.NetworkPeering parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.NetworkPeering parseFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.NetworkPeering parseDelimitedFrom(
      java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.NetworkPeering parseDelimitedFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.NetworkPeering parseFrom(
      com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.NetworkPeering parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() {
    return newBuilder();
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }

  public static Builder newBuilder(com.google.cloud.compute.v1.NetworkPeering prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   *
   *
   * <pre>
   * A network peering attached to a network resource. The message includes the peering name, peer network, peering state, and a flag indicating whether Google Compute Engine should automatically create routes for the peering.
   * </pre>
   *
   * Protobuf type {@code google.cloud.compute.v1.NetworkPeering}
   */
  public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
      implements
      // @@protoc_insertion_point(builder_implements:google.cloud.compute.v1.NetworkPeering)
      com.google.cloud.compute.v1.NetworkPeeringOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_NetworkPeering_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_NetworkPeering_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.cloud.compute.v1.NetworkPeering.class,
              com.google.cloud.compute.v1.NetworkPeering.Builder.class);
    }

    // Construct using com.google.cloud.compute.v1.NetworkPeering.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }

    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
    }

    @java.lang.Override
    public Builder clear() {
      super.clear();
      autoCreateRoutes_ = false;

      exchangeSubnetRoutes_ = false;

      exportCustomRoutes_ = false;

      exportSubnetRoutesWithPublicIp_ = false;

      importCustomRoutes_ = false;

      importSubnetRoutesWithPublicIp_ = false;

      name_ = "";

      network_ = "";

      peerMtu_ = 0;

      state_ = 0;

      stateDetails_ = "";

      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_NetworkPeering_descriptor;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.NetworkPeering getDefaultInstanceForType() {
      return com.google.cloud.compute.v1.NetworkPeering.getDefaultInstance();
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.NetworkPeering build() {
      com.google.cloud.compute.v1.NetworkPeering result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.NetworkPeering buildPartial() {
      com.google.cloud.compute.v1.NetworkPeering result =
          new com.google.cloud.compute.v1.NetworkPeering(this);
      result.autoCreateRoutes_ = autoCreateRoutes_;
      result.exchangeSubnetRoutes_ = exchangeSubnetRoutes_;
      result.exportCustomRoutes_ = exportCustomRoutes_;
      result.exportSubnetRoutesWithPublicIp_ = exportSubnetRoutesWithPublicIp_;
      result.importCustomRoutes_ = importCustomRoutes_;
      result.importSubnetRoutesWithPublicIp_ = importSubnetRoutesWithPublicIp_;
      result.name_ = name_;
      result.network_ = network_;
      result.peerMtu_ = peerMtu_;
      result.state_ = state_;
      result.stateDetails_ = stateDetails_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }

    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.setField(field, value);
    }

    @java.lang.Override
    public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }

    @java.lang.Override
    public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }

    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }

    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }

    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.google.cloud.compute.v1.NetworkPeering) {
        return mergeFrom((com.google.cloud.compute.v1.NetworkPeering) other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.google.cloud.compute.v1.NetworkPeering other) {
      if (other == com.google.cloud.compute.v1.NetworkPeering.getDefaultInstance()) return this;
      if (other.getAutoCreateRoutes() != false) {
        setAutoCreateRoutes(other.getAutoCreateRoutes());
      }
      if (other.getExchangeSubnetRoutes() != false) {
        setExchangeSubnetRoutes(other.getExchangeSubnetRoutes());
      }
      if (other.getExportCustomRoutes() != false) {
        setExportCustomRoutes(other.getExportCustomRoutes());
      }
      if (other.getExportSubnetRoutesWithPublicIp() != false) {
        setExportSubnetRoutesWithPublicIp(other.getExportSubnetRoutesWithPublicIp());
      }
      if (other.getImportCustomRoutes() != false) {
        setImportCustomRoutes(other.getImportCustomRoutes());
      }
      if (other.getImportSubnetRoutesWithPublicIp() != false) {
        setImportSubnetRoutesWithPublicIp(other.getImportSubnetRoutesWithPublicIp());
      }
      if (!other.getName().isEmpty()) {
        name_ = other.name_;
        onChanged();
      }
      if (!other.getNetwork().isEmpty()) {
        network_ = other.network_;
        onChanged();
      }
      if (other.getPeerMtu() != 0) {
        setPeerMtu(other.getPeerMtu());
      }
      if (other.state_ != 0) {
        setStateValue(other.getStateValue());
      }
      if (!other.getStateDetails().isEmpty()) {
        stateDetails_ = other.stateDetails_;
        onChanged();
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      com.google.cloud.compute.v1.NetworkPeering parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (com.google.cloud.compute.v1.NetworkPeering) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }

    private boolean autoCreateRoutes_;
    /**
     *
     *
     * <pre>
     * This field will be deprecated soon. Use the exchange_subnet_routes field instead. Indicates whether full mesh connectivity is created and managed automatically between peered networks. Currently this field should always be true since Google Compute Engine will automatically create and manage subnetwork routes between two networks when peering state is ACTIVE.
     * </pre>
     *
     * <code>bool auto_create_routes = 57454941;</code>
     *
     * @return The autoCreateRoutes.
     */
    @java.lang.Override
    public boolean getAutoCreateRoutes() {
      return autoCreateRoutes_;
    }
    /**
     *
     *
     * <pre>
     * This field will be deprecated soon. Use the exchange_subnet_routes field instead. Indicates whether full mesh connectivity is created and managed automatically between peered networks. Currently this field should always be true since Google Compute Engine will automatically create and manage subnetwork routes between two networks when peering state is ACTIVE.
     * </pre>
     *
     * <code>bool auto_create_routes = 57454941;</code>
     *
     * @param value The autoCreateRoutes to set.
     * @return This builder for chaining.
     */
    public Builder setAutoCreateRoutes(boolean value) {

      autoCreateRoutes_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field will be deprecated soon. Use the exchange_subnet_routes field instead. Indicates whether full mesh connectivity is created and managed automatically between peered networks. Currently this field should always be true since Google Compute Engine will automatically create and manage subnetwork routes between two networks when peering state is ACTIVE.
     * </pre>
     *
     * <code>bool auto_create_routes = 57454941;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearAutoCreateRoutes() {

      autoCreateRoutes_ = false;
      onChanged();
      return this;
    }

    private boolean exchangeSubnetRoutes_;
    /**
     *
     *
     * <pre>
     * Indicates whether full mesh connectivity is created and managed automatically between peered networks. Currently this field should always be true since Google Compute Engine will automatically create and manage subnetwork routes between two networks when peering state is ACTIVE.
     * </pre>
     *
     * <code>bool exchange_subnet_routes = 26322256;</code>
     *
     * @return The exchangeSubnetRoutes.
     */
    @java.lang.Override
    public boolean getExchangeSubnetRoutes() {
      return exchangeSubnetRoutes_;
    }
    /**
     *
     *
     * <pre>
     * Indicates whether full mesh connectivity is created and managed automatically between peered networks. Currently this field should always be true since Google Compute Engine will automatically create and manage subnetwork routes between two networks when peering state is ACTIVE.
     * </pre>
     *
     * <code>bool exchange_subnet_routes = 26322256;</code>
     *
     * @param value The exchangeSubnetRoutes to set.
     * @return This builder for chaining.
     */
    public Builder setExchangeSubnetRoutes(boolean value) {

      exchangeSubnetRoutes_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Indicates whether full mesh connectivity is created and managed automatically between peered networks. Currently this field should always be true since Google Compute Engine will automatically create and manage subnetwork routes between two networks when peering state is ACTIVE.
     * </pre>
     *
     * <code>bool exchange_subnet_routes = 26322256;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearExchangeSubnetRoutes() {

      exchangeSubnetRoutes_ = false;
      onChanged();
      return this;
    }

    private boolean exportCustomRoutes_;
    /**
     *
     *
     * <pre>
     * Whether to export the custom routes to peer network.
     * </pre>
     *
     * <code>bool export_custom_routes = 60281485;</code>
     *
     * @return The exportCustomRoutes.
     */
    @java.lang.Override
    public boolean getExportCustomRoutes() {
      return exportCustomRoutes_;
    }
    /**
     *
     *
     * <pre>
     * Whether to export the custom routes to peer network.
     * </pre>
     *
     * <code>bool export_custom_routes = 60281485;</code>
     *
     * @param value The exportCustomRoutes to set.
     * @return This builder for chaining.
     */
    public Builder setExportCustomRoutes(boolean value) {

      exportCustomRoutes_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Whether to export the custom routes to peer network.
     * </pre>
     *
     * <code>bool export_custom_routes = 60281485;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearExportCustomRoutes() {

      exportCustomRoutes_ = false;
      onChanged();
      return this;
    }

    private boolean exportSubnetRoutesWithPublicIp_;
    /**
     *
     *
     * <pre>
     * Whether subnet routes with public IP range are exported. The default value is true, all subnet routes are exported. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always exported to peers and are not controlled by this field.
     * </pre>
     *
     * <code>bool export_subnet_routes_with_public_ip = 97940834;</code>
     *
     * @return The exportSubnetRoutesWithPublicIp.
     */
    @java.lang.Override
    public boolean getExportSubnetRoutesWithPublicIp() {
      return exportSubnetRoutesWithPublicIp_;
    }
    /**
     *
     *
     * <pre>
     * Whether subnet routes with public IP range are exported. The default value is true, all subnet routes are exported. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always exported to peers and are not controlled by this field.
     * </pre>
     *
     * <code>bool export_subnet_routes_with_public_ip = 97940834;</code>
     *
     * @param value The exportSubnetRoutesWithPublicIp to set.
     * @return This builder for chaining.
     */
    public Builder setExportSubnetRoutesWithPublicIp(boolean value) {

      exportSubnetRoutesWithPublicIp_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Whether subnet routes with public IP range are exported. The default value is true, all subnet routes are exported. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always exported to peers and are not controlled by this field.
     * </pre>
     *
     * <code>bool export_subnet_routes_with_public_ip = 97940834;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearExportSubnetRoutesWithPublicIp() {

      exportSubnetRoutesWithPublicIp_ = false;
      onChanged();
      return this;
    }

    private boolean importCustomRoutes_;
    /**
     *
     *
     * <pre>
     * Whether to import the custom routes from peer network.
     * </pre>
     *
     * <code>bool import_custom_routes = 197982398;</code>
     *
     * @return The importCustomRoutes.
     */
    @java.lang.Override
    public boolean getImportCustomRoutes() {
      return importCustomRoutes_;
    }
    /**
     *
     *
     * <pre>
     * Whether to import the custom routes from peer network.
     * </pre>
     *
     * <code>bool import_custom_routes = 197982398;</code>
     *
     * @param value The importCustomRoutes to set.
     * @return This builder for chaining.
     */
    public Builder setImportCustomRoutes(boolean value) {

      importCustomRoutes_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Whether to import the custom routes from peer network.
     * </pre>
     *
     * <code>bool import_custom_routes = 197982398;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearImportCustomRoutes() {

      importCustomRoutes_ = false;
      onChanged();
      return this;
    }

    private boolean importSubnetRoutesWithPublicIp_;
    /**
     *
     *
     * <pre>
     * Whether subnet routes with public IP range are imported. The default value is false. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always imported from peers and are not controlled by this field.
     * </pre>
     *
     * <code>bool import_subnet_routes_with_public_ip = 14419729;</code>
     *
     * @return The importSubnetRoutesWithPublicIp.
     */
    @java.lang.Override
    public boolean getImportSubnetRoutesWithPublicIp() {
      return importSubnetRoutesWithPublicIp_;
    }
    /**
     *
     *
     * <pre>
     * Whether subnet routes with public IP range are imported. The default value is false. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always imported from peers and are not controlled by this field.
     * </pre>
     *
     * <code>bool import_subnet_routes_with_public_ip = 14419729;</code>
     *
     * @param value The importSubnetRoutesWithPublicIp to set.
     * @return This builder for chaining.
     */
    public Builder setImportSubnetRoutesWithPublicIp(boolean value) {

      importSubnetRoutesWithPublicIp_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Whether subnet routes with public IP range are imported. The default value is false. The IPv4 special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always imported from peers and are not controlled by this field.
     * </pre>
     *
     * <code>bool import_subnet_routes_with_public_ip = 14419729;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearImportSubnetRoutesWithPublicIp() {

      importSubnetRoutesWithPublicIp_ = false;
      onChanged();
      return this;
    }

    private java.lang.Object name_ = "";
    /**
     *
     *
     * <pre>
     * Name of this peering. Provided by the client when the peering is created. The name must comply with RFC1035. Specifically, the name must be 1-63 characters long and match regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase letter, and all the following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @return The name.
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Name of this peering. Provided by the client when the peering is created. The name must comply with RFC1035. Specifically, the name must be 1-63 characters long and match regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase letter, and all the following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @return The bytes for name.
     */
    public com.google.protobuf.ByteString getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Name of this peering. Provided by the client when the peering is created. The name must comply with RFC1035. Specifically, the name must be 1-63 characters long and match regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase letter, and all the following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @param value The name to set.
     * @return This builder for chaining.
     */
    public Builder setName(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }

      name_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Name of this peering. Provided by the client when the peering is created. The name must comply with RFC1035. Specifically, the name must be 1-63 characters long and match regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase letter, and all the following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearName() {

      name_ = getDefaultInstance().getName();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Name of this peering. Provided by the client when the peering is created. The name must comply with RFC1035. Specifically, the name must be 1-63 characters long and match regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase letter, and all the following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
     * </pre>
     *
     * <code>string name = 3373707;</code>
     *
     * @param value The bytes for name to set.
     * @return This builder for chaining.
     */
    public Builder setNameBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);

      name_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object network_ = "";
    /**
     *
     *
     * <pre>
     * The URL of the peer network. It can be either full URL or partial URL. The peer network may belong to a different project. If the partial URL does not contain project, it is assumed that the peer network is in the same project as the current network.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @return The network.
     */
    public java.lang.String getNetwork() {
      java.lang.Object ref = network_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        network_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * The URL of the peer network. It can be either full URL or partial URL. The peer network may belong to a different project. If the partial URL does not contain project, it is assumed that the peer network is in the same project as the current network.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @return The bytes for network.
     */
    public com.google.protobuf.ByteString getNetworkBytes() {
      java.lang.Object ref = network_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        network_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * The URL of the peer network. It can be either full URL or partial URL. The peer network may belong to a different project. If the partial URL does not contain project, it is assumed that the peer network is in the same project as the current network.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @param value The network to set.
     * @return This builder for chaining.
     */
    public Builder setNetwork(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }

      network_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The URL of the peer network. It can be either full URL or partial URL. The peer network may belong to a different project. If the partial URL does not contain project, it is assumed that the peer network is in the same project as the current network.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearNetwork() {

      network_ = getDefaultInstance().getNetwork();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The URL of the peer network. It can be either full URL or partial URL. The peer network may belong to a different project. If the partial URL does not contain project, it is assumed that the peer network is in the same project as the current network.
     * </pre>
     *
     * <code>string network = 232872494;</code>
     *
     * @param value The bytes for network to set.
     * @return This builder for chaining.
     */
    public Builder setNetworkBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);

      network_ = value;
      onChanged();
      return this;
    }

    private int peerMtu_;
    /**
     *
     *
     * <pre>
     * Maximum Transmission Unit in bytes.
     * </pre>
     *
     * <code>int32 peer_mtu = 69584721;</code>
     *
     * @return The peerMtu.
     */
    @java.lang.Override
    public int getPeerMtu() {
      return peerMtu_;
    }
    /**
     *
     *
     * <pre>
     * Maximum Transmission Unit in bytes.
     * </pre>
     *
     * <code>int32 peer_mtu = 69584721;</code>
     *
     * @param value The peerMtu to set.
     * @return This builder for chaining.
     */
    public Builder setPeerMtu(int value) {

      peerMtu_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Maximum Transmission Unit in bytes.
     * </pre>
     *
     * <code>int32 peer_mtu = 69584721;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearPeerMtu() {

      peerMtu_ = 0;
      onChanged();
      return this;
    }

    private int state_ = 0;
    /**
     *
     *
     * <pre>
     * [Output Only] State for the peering, either `ACTIVE` or `INACTIVE`. The peering is `ACTIVE` when there's a matching configuration in the peer network.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.NetworkPeering.State state = 109757585;</code>
     *
     * @return The enum numeric value on the wire for state.
     */
    @java.lang.Override
    public int getStateValue() {
      return state_;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] State for the peering, either `ACTIVE` or `INACTIVE`. The peering is `ACTIVE` when there's a matching configuration in the peer network.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.NetworkPeering.State state = 109757585;</code>
     *
     * @param value The enum numeric value on the wire for state to set.
     * @return This builder for chaining.
     */
    public Builder setStateValue(int value) {

      state_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] State for the peering, either `ACTIVE` or `INACTIVE`. The peering is `ACTIVE` when there's a matching configuration in the peer network.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.NetworkPeering.State state = 109757585;</code>
     *
     * @return The state.
     */
    @java.lang.Override
    public com.google.cloud.compute.v1.NetworkPeering.State getState() {
      @SuppressWarnings("deprecation")
      com.google.cloud.compute.v1.NetworkPeering.State result =
          com.google.cloud.compute.v1.NetworkPeering.State.valueOf(state_);
      return result == null
          ? com.google.cloud.compute.v1.NetworkPeering.State.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] State for the peering, either `ACTIVE` or `INACTIVE`. The peering is `ACTIVE` when there's a matching configuration in the peer network.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.NetworkPeering.State state = 109757585;</code>
     *
     * @param value The state to set.
     * @return This builder for chaining.
     */
    public Builder setState(com.google.cloud.compute.v1.NetworkPeering.State value) {
      if (value == null) {
        throw new NullPointerException();
      }

      state_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] State for the peering, either `ACTIVE` or `INACTIVE`. The peering is `ACTIVE` when there's a matching configuration in the peer network.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.NetworkPeering.State state = 109757585;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearState() {

      state_ = 0;
      onChanged();
      return this;
    }

    private java.lang.Object stateDetails_ = "";
    /**
     *
     *
     * <pre>
     * [Output Only] Details about the current state of the peering.
     * </pre>
     *
     * <code>string state_details = 95566996;</code>
     *
     * @return The stateDetails.
     */
    public java.lang.String getStateDetails() {
      java.lang.Object ref = stateDetails_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        stateDetails_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Details about the current state of the peering.
     * </pre>
     *
     * <code>string state_details = 95566996;</code>
     *
     * @return The bytes for stateDetails.
     */
    public com.google.protobuf.ByteString getStateDetailsBytes() {
      java.lang.Object ref = stateDetails_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        stateDetails_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Details about the current state of the peering.
     * </pre>
     *
     * <code>string state_details = 95566996;</code>
     *
     * @param value The stateDetails to set.
     * @return This builder for chaining.
     */
    public Builder setStateDetails(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }

      stateDetails_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Details about the current state of the peering.
     * </pre>
     *
     * <code>string state_details = 95566996;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearStateDetails() {

      stateDetails_ = getDefaultInstance().getStateDetails();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * [Output Only] Details about the current state of the peering.
     * </pre>
     *
     * <code>string state_details = 95566996;</code>
     *
     * @param value The bytes for stateDetails to set.
     * @return This builder for chaining.
     */
    public Builder setStateDetailsBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);

      stateDetails_ = value;
      onChanged();
      return this;
    }

    @java.lang.Override
    public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }

    // @@protoc_insertion_point(builder_scope:google.cloud.compute.v1.NetworkPeering)
  }

  // @@protoc_insertion_point(class_scope:google.cloud.compute.v1.NetworkPeering)
  private static final com.google.cloud.compute.v1.NetworkPeering DEFAULT_INSTANCE;

  static {
    DEFAULT_INSTANCE = new com.google.cloud.compute.v1.NetworkPeering();
  }

  public static com.google.cloud.compute.v1.NetworkPeering getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<NetworkPeering> PARSER =
      new com.google.protobuf.AbstractParser<NetworkPeering>() {
        @java.lang.Override
        public NetworkPeering parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new NetworkPeering(input, extensionRegistry);
        }
      };

  public static com.google.protobuf.Parser<NetworkPeering> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<NetworkPeering> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.cloud.compute.v1.NetworkPeering getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }
}
