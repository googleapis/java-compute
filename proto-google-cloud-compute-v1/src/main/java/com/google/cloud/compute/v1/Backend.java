/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/compute/v1/compute.proto

package com.google.cloud.compute.v1;

/**
 *
 *
 * <pre>
 * Message containing information of one individual backend.
 * </pre>
 *
 * Protobuf type {@code google.cloud.compute.v1.Backend}
 */
public final class Backend extends com.google.protobuf.GeneratedMessageV3
    implements
    // @@protoc_insertion_point(message_implements:google.cloud.compute.v1.Backend)
    BackendOrBuilder {
  private static final long serialVersionUID = 0L;
  // Use Backend.newBuilder() to construct.
  private Backend(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }

  private Backend() {
    balancingMode_ = 0;
    description_ = "";
    group_ = "";
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
    return new Backend();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
  }

  private Backend(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 140796637:
            {
              maxRatePerInstance_ = input.readFloat();
              break;
            }
          case 380181613:
            {
              capacityScaler_ = input.readFloat();
              break;
            }
          case 789033978:
            {
              java.lang.String s = input.readStringRequireUtf8();

              group_ = s;
              break;
            }
          case 837375200:
            {
              maxConnectionsPerInstance_ = input.readInt32();
              break;
            }
          case 885217232:
            {
              maxConnections_ = input.readInt32();
              break;
            }
          case 1038658269:
            {
              maxRatePerEndpoint_ = input.readFloat();
              break;
            }
          case 1111140240:
            {
              failover_ = input.readBool();
              break;
            }
          case 1116796632:
            {
              maxRate_ = input.readInt32();
              break;
            }
          case 1185537597:
            {
              maxUtilization_ = input.readFloat();
              break;
            }
          case 1236017122:
            {
              java.lang.String s = input.readStringRequireUtf8();

              description_ = s;
              break;
            }
          case 1294806088:
            {
              int rawValue = input.readEnum();

              balancingMode_ = rawValue;
              break;
            }
          case 1735236832:
            {
              maxConnectionsPerEndpoint_ = input.readInt32();
              break;
            }
          default:
            {
              if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
    } finally {
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }

  public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_Backend_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_Backend_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.google.cloud.compute.v1.Backend.class,
            com.google.cloud.compute.v1.Backend.Builder.class);
  }

  /**
   *
   *
   * <pre>
   * Specifies the balancing mode for the backend.
   * When choosing a balancing mode, you need to consider the loadBalancingScheme, and protocol for the backend service, as well as the type of backend (instance group or NEG).
   * - If the load balancing mode is CONNECTION, then the load is spread based on how many concurrent connections the backend can handle.
   * You can use the CONNECTION balancing mode if the protocol for the backend service is SSL, TCP, or UDP.
   * If the loadBalancingScheme for the backend service is EXTERNAL (SSL Proxy and TCP Proxy load balancers), you must also specify exactly one of the following parameters: maxConnections (except for regional managed instance groups), maxConnectionsPerInstance, or maxConnectionsPerEndpoint.
   * If the loadBalancingScheme for the backend service is INTERNAL (internal TCP/UDP Load Balancers) or EXTERNAL  (Network Load Balancing), you cannot specify any additional parameters.
   * - If the load balancing mode is RATE, the load is spread based on the rate of HTTP requests per second (RPS).
   * You can use the RATE balancing mode if the protocol for the backend service is HTTP, HTTP2, or HTTPS. You must specify exactly one of the following parameters: maxRate (except for regional managed instance groups), maxRatePerInstance, or maxRatePerEndpoint.
   * - If the load balancing mode is UTILIZATION, the load is spread based on the backend utilization of instances in an instance group.
   * You can use the UTILIZATION balancing mode if the loadBalancingScheme of the backend service is EXTERNAL (except Network Load Balancing), INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED and the backends are instance groups. There are no restrictions on the backend service protocol.
   * </pre>
   *
   * Protobuf enum {@code google.cloud.compute.v1.Backend.BalancingMode}
   */
  public enum BalancingMode implements com.google.protobuf.ProtocolMessageEnum {
    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_BALANCING_MODE = 0;</code>
     */
    UNDEFINED_BALANCING_MODE(0),
    /** <code>CONNECTION = 246311646;</code> */
    CONNECTION(246311646),
    /** <code>RATE = 2508000;</code> */
    RATE(2508000),
    /** <code>UTILIZATION = 157008386;</code> */
    UTILIZATION(157008386),
    UNRECOGNIZED(-1),
    ;

    /**
     *
     *
     * <pre>
     * A value indicating that the enum field is not set.
     * </pre>
     *
     * <code>UNDEFINED_BALANCING_MODE = 0;</code>
     */
    public static final int UNDEFINED_BALANCING_MODE_VALUE = 0;
    /** <code>CONNECTION = 246311646;</code> */
    public static final int CONNECTION_VALUE = 246311646;
    /** <code>RATE = 2508000;</code> */
    public static final int RATE_VALUE = 2508000;
    /** <code>UTILIZATION = 157008386;</code> */
    public static final int UTILIZATION_VALUE = 157008386;

    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static BalancingMode valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static BalancingMode forNumber(int value) {
      switch (value) {
        case 0:
          return UNDEFINED_BALANCING_MODE;
        case 246311646:
          return CONNECTION;
        case 2508000:
          return RATE;
        case 157008386:
          return UTILIZATION;
        default:
          return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<BalancingMode> internalGetValueMap() {
      return internalValueMap;
    }

    private static final com.google.protobuf.Internal.EnumLiteMap<BalancingMode> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<BalancingMode>() {
          public BalancingMode findValueByNumber(int number) {
            return BalancingMode.forNumber(number);
          }
        };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }

    public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType() {
      return getDescriptor();
    }

    public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor() {
      return com.google.cloud.compute.v1.Backend.getDescriptor().getEnumTypes().get(0);
    }

    private static final BalancingMode[] VALUES = values();

    public static BalancingMode valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private BalancingMode(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.cloud.compute.v1.Backend.BalancingMode)
  }

  public static final int BALANCING_MODE_FIELD_NUMBER = 161850761;
  private int balancingMode_;
  /**
   *
   *
   * <pre>
   * Specifies the balancing mode for the backend.
   * When choosing a balancing mode, you need to consider the loadBalancingScheme, and protocol for the backend service, as well as the type of backend (instance group or NEG).
   * - If the load balancing mode is CONNECTION, then the load is spread based on how many concurrent connections the backend can handle.
   * You can use the CONNECTION balancing mode if the protocol for the backend service is SSL, TCP, or UDP.
   * If the loadBalancingScheme for the backend service is EXTERNAL (SSL Proxy and TCP Proxy load balancers), you must also specify exactly one of the following parameters: maxConnections (except for regional managed instance groups), maxConnectionsPerInstance, or maxConnectionsPerEndpoint.
   * If the loadBalancingScheme for the backend service is INTERNAL (internal TCP/UDP Load Balancers) or EXTERNAL  (Network Load Balancing), you cannot specify any additional parameters.
   * - If the load balancing mode is RATE, the load is spread based on the rate of HTTP requests per second (RPS).
   * You can use the RATE balancing mode if the protocol for the backend service is HTTP, HTTP2, or HTTPS. You must specify exactly one of the following parameters: maxRate (except for regional managed instance groups), maxRatePerInstance, or maxRatePerEndpoint.
   * - If the load balancing mode is UTILIZATION, the load is spread based on the backend utilization of instances in an instance group.
   * You can use the UTILIZATION balancing mode if the loadBalancingScheme of the backend service is EXTERNAL (except Network Load Balancing), INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED and the backends are instance groups. There are no restrictions on the backend service protocol.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.Backend.BalancingMode balancing_mode = 161850761;</code>
   *
   * @return The enum numeric value on the wire for balancingMode.
   */
  @java.lang.Override
  public int getBalancingModeValue() {
    return balancingMode_;
  }
  /**
   *
   *
   * <pre>
   * Specifies the balancing mode for the backend.
   * When choosing a balancing mode, you need to consider the loadBalancingScheme, and protocol for the backend service, as well as the type of backend (instance group or NEG).
   * - If the load balancing mode is CONNECTION, then the load is spread based on how many concurrent connections the backend can handle.
   * You can use the CONNECTION balancing mode if the protocol for the backend service is SSL, TCP, or UDP.
   * If the loadBalancingScheme for the backend service is EXTERNAL (SSL Proxy and TCP Proxy load balancers), you must also specify exactly one of the following parameters: maxConnections (except for regional managed instance groups), maxConnectionsPerInstance, or maxConnectionsPerEndpoint.
   * If the loadBalancingScheme for the backend service is INTERNAL (internal TCP/UDP Load Balancers) or EXTERNAL  (Network Load Balancing), you cannot specify any additional parameters.
   * - If the load balancing mode is RATE, the load is spread based on the rate of HTTP requests per second (RPS).
   * You can use the RATE balancing mode if the protocol for the backend service is HTTP, HTTP2, or HTTPS. You must specify exactly one of the following parameters: maxRate (except for regional managed instance groups), maxRatePerInstance, or maxRatePerEndpoint.
   * - If the load balancing mode is UTILIZATION, the load is spread based on the backend utilization of instances in an instance group.
   * You can use the UTILIZATION balancing mode if the loadBalancingScheme of the backend service is EXTERNAL (except Network Load Balancing), INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED and the backends are instance groups. There are no restrictions on the backend service protocol.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.Backend.BalancingMode balancing_mode = 161850761;</code>
   *
   * @return The balancingMode.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.Backend.BalancingMode getBalancingMode() {
    @SuppressWarnings("deprecation")
    com.google.cloud.compute.v1.Backend.BalancingMode result =
        com.google.cloud.compute.v1.Backend.BalancingMode.valueOf(balancingMode_);
    return result == null ? com.google.cloud.compute.v1.Backend.BalancingMode.UNRECOGNIZED : result;
  }

  public static final int CAPACITY_SCALER_FIELD_NUMBER = 47522701;
  private float capacityScaler_;
  /**
   *
   *
   * <pre>
   * A multiplier applied to the group's maximum servicing capacity (based on UTILIZATION, RATE or CONNECTION). Default value is 1, which means the group will serve up to 100% of its configured capacity (depending on balancingMode). A setting of 0 means the group is completely drained, offering 0% of its available capacity. Valid range is 0.0 and [0.1,1.0]. You cannot configure a setting larger than 0 and smaller than 0.1. You cannot configure a setting of 0 when there is only one backend attached to the backend service.
   * This cannot be used for Internal TCP/UDP Load Balancing and Network Load Balancing.
   * </pre>
   *
   * <code>float capacity_scaler = 47522701;</code>
   *
   * @return The capacityScaler.
   */
  @java.lang.Override
  public float getCapacityScaler() {
    return capacityScaler_;
  }

  public static final int DESCRIPTION_FIELD_NUMBER = 154502140;
  private volatile java.lang.Object description_;
  /**
   *
   *
   * <pre>
   * An optional description of this resource. Provide this property when you create the resource.
   * </pre>
   *
   * <code>string description = 154502140;</code>
   *
   * @return The description.
   */
  @java.lang.Override
  public java.lang.String getDescription() {
    java.lang.Object ref = description_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      description_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * An optional description of this resource. Provide this property when you create the resource.
   * </pre>
   *
   * <code>string description = 154502140;</code>
   *
   * @return The bytes for description.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getDescriptionBytes() {
    java.lang.Object ref = description_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      description_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int FAILOVER_FIELD_NUMBER = 138892530;
  private boolean failover_;
  /**
   *
   *
   * <pre>
   * This field designates whether this is a failover backend. More than one failover backend can be configured for a given BackendService.
   * </pre>
   *
   * <code>bool failover = 138892530;</code>
   *
   * @return The failover.
   */
  @java.lang.Override
  public boolean getFailover() {
    return failover_;
  }

  public static final int GROUP_FIELD_NUMBER = 98629247;
  private volatile java.lang.Object group_;
  /**
   *
   *
   * <pre>
   * The fully-qualified URL of an instance group or network endpoint group (NEG) resource. The type of backend that a backend service supports depends on the backend service's loadBalancingScheme.
   * - When the loadBalancingScheme for the backend service is EXTERNAL (except Network Load Balancing),  INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED , the backend can be either an instance group or a NEG. The backends on the backend service must be either all instance groups or all NEGs. You cannot mix instance group and NEG backends on the same backend service.
   * - When the loadBalancingScheme for the backend service is EXTERNAL for Network Load Balancing or INTERNAL for Internal TCP/UDP Load Balancing, the backend must be an instance group. NEGs are not supported.
   * For regional services, the backend must be in the same region as the backend service.
   * You must use the fully-qualified URL (starting with https://www.googleapis.com/) to specify the instance group or NEG. Partial URLs are not supported.
   * </pre>
   *
   * <code>string group = 98629247;</code>
   *
   * @return The group.
   */
  @java.lang.Override
  public java.lang.String getGroup() {
    java.lang.Object ref = group_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      group_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * The fully-qualified URL of an instance group or network endpoint group (NEG) resource. The type of backend that a backend service supports depends on the backend service's loadBalancingScheme.
   * - When the loadBalancingScheme for the backend service is EXTERNAL (except Network Load Balancing),  INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED , the backend can be either an instance group or a NEG. The backends on the backend service must be either all instance groups or all NEGs. You cannot mix instance group and NEG backends on the same backend service.
   * - When the loadBalancingScheme for the backend service is EXTERNAL for Network Load Balancing or INTERNAL for Internal TCP/UDP Load Balancing, the backend must be an instance group. NEGs are not supported.
   * For regional services, the backend must be in the same region as the backend service.
   * You must use the fully-qualified URL (starting with https://www.googleapis.com/) to specify the instance group or NEG. Partial URLs are not supported.
   * </pre>
   *
   * <code>string group = 98629247;</code>
   *
   * @return The bytes for group.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getGroupBytes() {
    java.lang.Object ref = group_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      group_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int MAX_CONNECTIONS_FIELD_NUMBER = 110652154;
  private int maxConnections_;
  /**
   *
   *
   * <pre>
   * Defines a target maximum number of simultaneous connections that the backend can handle. Valid for network endpoint group and instance group backends (except for regional managed instance groups). If the backend's balancingMode is UTILIZATION, this is an optional parameter. If the backend's balancingMode is CONNECTION, and backend is attached to a backend service whose loadBalancingScheme is EXTERNAL (except Network Load Balancing), you must specify either this parameter, maxConnectionsPerInstance, or maxConnectionsPerEndpoint.
   * Not available if the backend's balancingMode is RATE. Cannot be specified for Network Load Balancing or Internal TCP/UDP Load Balancing, even though those load balancers require a balancing mode of CONNECTION.
   * </pre>
   *
   * <code>int32 max_connections = 110652154;</code>
   *
   * @return The maxConnections.
   */
  @java.lang.Override
  public int getMaxConnections() {
    return maxConnections_;
  }

  public static final int MAX_CONNECTIONS_PER_ENDPOINT_FIELD_NUMBER = 216904604;
  private int maxConnectionsPerEndpoint_;
  /**
   *
   *
   * <pre>
   * Defines a target maximum number of simultaneous connections for an endpoint of a NEG. This is multiplied by the number of endpoints in the NEG to implicitly calculate a maximum number of target maximum simultaneous connections for the NEG. If the backend's balancingMode is CONNECTION, and backend is attached to a backend service whose loadBalancingScheme is EXTERNAL (except Network Load Balancing), you must specify either this parameter, maxConnections, or maxConnectionsPerInstance.
   * Not available if the backend's balancingMode is RATE. Cannot be specified for Network Load Balancing or Internal TCP/UDP Load Balancing, even though those load balancers require a balancing mode of CONNECTION.
   * </pre>
   *
   * <code>int32 max_connections_per_endpoint = 216904604;</code>
   *
   * @return The maxConnectionsPerEndpoint.
   */
  @java.lang.Override
  public int getMaxConnectionsPerEndpoint() {
    return maxConnectionsPerEndpoint_;
  }

  public static final int MAX_CONNECTIONS_PER_INSTANCE_FIELD_NUMBER = 104671900;
  private int maxConnectionsPerInstance_;
  /**
   *
   *
   * <pre>
   * Defines a target maximum number of simultaneous connections for a single VM in a backend instance group. This is multiplied by the number of instances in the instance group to implicitly calculate a target maximum number of simultaneous connections for the whole instance group. If the backend's balancingMode is UTILIZATION, this is an optional parameter. If the backend's balancingMode is CONNECTION, and backend is attached to a backend service whose loadBalancingScheme is EXTERNAL (except Network Load Balancing), you must specify either this parameter,  maxConnections, or maxConnectionsPerEndpoint.
   * Not available if the backend's balancingMode is RATE. Cannot be specified for Network Load Balancing or Internal TCP/UDP Load Balancing, even though those load balancers require a balancing mode of CONNECTION.
   * </pre>
   *
   * <code>int32 max_connections_per_instance = 104671900;</code>
   *
   * @return The maxConnectionsPerInstance.
   */
  @java.lang.Override
  public int getMaxConnectionsPerInstance() {
    return maxConnectionsPerInstance_;
  }

  public static final int MAX_RATE_FIELD_NUMBER = 139599579;
  private int maxRate_;
  /**
   *
   *
   * <pre>
   * Defines a maximum number of HTTP requests per second (RPS) that the backend can handle. Valid for network endpoint group and instance group backends (except for regional managed instance groups). Must not be defined if the backend is a managed instance group that uses autoscaling based on load balancing.
   * If the backend's balancingMode is UTILIZATION, this is an optional parameter. If the backend's balancingMode is RATE, you must specify maxRate, maxRatePerInstance, or maxRatePerEndpoint.
   * Not available if the backend's balancingMode is CONNECTION.
   * </pre>
   *
   * <code>int32 max_rate = 139599579;</code>
   *
   * @return The maxRate.
   */
  @java.lang.Override
  public int getMaxRate() {
    return maxRate_;
  }

  public static final int MAX_RATE_PER_ENDPOINT_FIELD_NUMBER = 129832283;
  private float maxRatePerEndpoint_;
  /**
   *
   *
   * <pre>
   * Defines a maximum target for requests per second (RPS) for an endpoint of a NEG. This is multiplied by the number of endpoints in the NEG to implicitly calculate a target maximum rate for the NEG.
   * If the backend's balancingMode is RATE, you must specify either this parameter, maxRate (except for regional managed instance groups), or maxRatePerInstance.
   * Not available if the backend's balancingMode is CONNECTION.
   * </pre>
   *
   * <code>float max_rate_per_endpoint = 129832283;</code>
   *
   * @return The maxRatePerEndpoint.
   */
  @java.lang.Override
  public float getMaxRatePerEndpoint() {
    return maxRatePerEndpoint_;
  }

  public static final int MAX_RATE_PER_INSTANCE_FIELD_NUMBER = 17599579;
  private float maxRatePerInstance_;
  /**
   *
   *
   * <pre>
   * Defines a maximum target for requests per second (RPS) for a single VM in a backend instance group. This is multiplied by the number of instances in the instance group to implicitly calculate a target maximum rate for the whole instance group.
   * If the backend's balancingMode is UTILIZATION, this is an optional parameter. If the backend's balancingMode is RATE, you must specify either this parameter, maxRate (except for regional managed instance groups), or maxRatePerEndpoint.
   * Not available if the backend's balancingMode is CONNECTION.
   * </pre>
   *
   * <code>float max_rate_per_instance = 17599579;</code>
   *
   * @return The maxRatePerInstance.
   */
  @java.lang.Override
  public float getMaxRatePerInstance() {
    return maxRatePerInstance_;
  }

  public static final int MAX_UTILIZATION_FIELD_NUMBER = 148192199;
  private float maxUtilization_;
  /**
   *
   *
   * <pre>
   * Defines the maximum average backend utilization of a backend VM in an instance group. The valid range is [0.0, 1.0]. This is an optional parameter if the backend's balancingMode is UTILIZATION.
   * This parameter can be used in conjunction with maxRate, maxRatePerInstance, maxConnections (except for regional managed instance groups), or maxConnectionsPerInstance.
   * </pre>
   *
   * <code>float max_utilization = 148192199;</code>
   *
   * @return The maxUtilization.
   */
  @java.lang.Override
  public float getMaxUtilization() {
    return maxUtilization_;
  }

  private byte memoizedIsInitialized = -1;

  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    if (maxRatePerInstance_ != 0F) {
      output.writeFloat(17599579, maxRatePerInstance_);
    }
    if (capacityScaler_ != 0F) {
      output.writeFloat(47522701, capacityScaler_);
    }
    if (!getGroupBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 98629247, group_);
    }
    if (maxConnectionsPerInstance_ != 0) {
      output.writeInt32(104671900, maxConnectionsPerInstance_);
    }
    if (maxConnections_ != 0) {
      output.writeInt32(110652154, maxConnections_);
    }
    if (maxRatePerEndpoint_ != 0F) {
      output.writeFloat(129832283, maxRatePerEndpoint_);
    }
    if (failover_ != false) {
      output.writeBool(138892530, failover_);
    }
    if (maxRate_ != 0) {
      output.writeInt32(139599579, maxRate_);
    }
    if (maxUtilization_ != 0F) {
      output.writeFloat(148192199, maxUtilization_);
    }
    if (!getDescriptionBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 154502140, description_);
    }
    if (balancingMode_
        != com.google.cloud.compute.v1.Backend.BalancingMode.UNDEFINED_BALANCING_MODE.getNumber()) {
      output.writeEnum(161850761, balancingMode_);
    }
    if (maxConnectionsPerEndpoint_ != 0) {
      output.writeInt32(216904604, maxConnectionsPerEndpoint_);
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (maxRatePerInstance_ != 0F) {
      size += com.google.protobuf.CodedOutputStream.computeFloatSize(17599579, maxRatePerInstance_);
    }
    if (capacityScaler_ != 0F) {
      size += com.google.protobuf.CodedOutputStream.computeFloatSize(47522701, capacityScaler_);
    }
    if (!getGroupBytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(98629247, group_);
    }
    if (maxConnectionsPerInstance_ != 0) {
      size +=
          com.google.protobuf.CodedOutputStream.computeInt32Size(
              104671900, maxConnectionsPerInstance_);
    }
    if (maxConnections_ != 0) {
      size += com.google.protobuf.CodedOutputStream.computeInt32Size(110652154, maxConnections_);
    }
    if (maxRatePerEndpoint_ != 0F) {
      size +=
          com.google.protobuf.CodedOutputStream.computeFloatSize(129832283, maxRatePerEndpoint_);
    }
    if (failover_ != false) {
      size += com.google.protobuf.CodedOutputStream.computeBoolSize(138892530, failover_);
    }
    if (maxRate_ != 0) {
      size += com.google.protobuf.CodedOutputStream.computeInt32Size(139599579, maxRate_);
    }
    if (maxUtilization_ != 0F) {
      size += com.google.protobuf.CodedOutputStream.computeFloatSize(148192199, maxUtilization_);
    }
    if (!getDescriptionBytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(154502140, description_);
    }
    if (balancingMode_
        != com.google.cloud.compute.v1.Backend.BalancingMode.UNDEFINED_BALANCING_MODE.getNumber()) {
      size += com.google.protobuf.CodedOutputStream.computeEnumSize(161850761, balancingMode_);
    }
    if (maxConnectionsPerEndpoint_ != 0) {
      size +=
          com.google.protobuf.CodedOutputStream.computeInt32Size(
              216904604, maxConnectionsPerEndpoint_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof com.google.cloud.compute.v1.Backend)) {
      return super.equals(obj);
    }
    com.google.cloud.compute.v1.Backend other = (com.google.cloud.compute.v1.Backend) obj;

    if (balancingMode_ != other.balancingMode_) return false;
    if (java.lang.Float.floatToIntBits(getCapacityScaler())
        != java.lang.Float.floatToIntBits(other.getCapacityScaler())) return false;
    if (!getDescription().equals(other.getDescription())) return false;
    if (getFailover() != other.getFailover()) return false;
    if (!getGroup().equals(other.getGroup())) return false;
    if (getMaxConnections() != other.getMaxConnections()) return false;
    if (getMaxConnectionsPerEndpoint() != other.getMaxConnectionsPerEndpoint()) return false;
    if (getMaxConnectionsPerInstance() != other.getMaxConnectionsPerInstance()) return false;
    if (getMaxRate() != other.getMaxRate()) return false;
    if (java.lang.Float.floatToIntBits(getMaxRatePerEndpoint())
        != java.lang.Float.floatToIntBits(other.getMaxRatePerEndpoint())) return false;
    if (java.lang.Float.floatToIntBits(getMaxRatePerInstance())
        != java.lang.Float.floatToIntBits(other.getMaxRatePerInstance())) return false;
    if (java.lang.Float.floatToIntBits(getMaxUtilization())
        != java.lang.Float.floatToIntBits(other.getMaxUtilization())) return false;
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    hash = (37 * hash) + BALANCING_MODE_FIELD_NUMBER;
    hash = (53 * hash) + balancingMode_;
    hash = (37 * hash) + CAPACITY_SCALER_FIELD_NUMBER;
    hash = (53 * hash) + java.lang.Float.floatToIntBits(getCapacityScaler());
    hash = (37 * hash) + DESCRIPTION_FIELD_NUMBER;
    hash = (53 * hash) + getDescription().hashCode();
    hash = (37 * hash) + FAILOVER_FIELD_NUMBER;
    hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getFailover());
    hash = (37 * hash) + GROUP_FIELD_NUMBER;
    hash = (53 * hash) + getGroup().hashCode();
    hash = (37 * hash) + MAX_CONNECTIONS_FIELD_NUMBER;
    hash = (53 * hash) + getMaxConnections();
    hash = (37 * hash) + MAX_CONNECTIONS_PER_ENDPOINT_FIELD_NUMBER;
    hash = (53 * hash) + getMaxConnectionsPerEndpoint();
    hash = (37 * hash) + MAX_CONNECTIONS_PER_INSTANCE_FIELD_NUMBER;
    hash = (53 * hash) + getMaxConnectionsPerInstance();
    hash = (37 * hash) + MAX_RATE_FIELD_NUMBER;
    hash = (53 * hash) + getMaxRate();
    hash = (37 * hash) + MAX_RATE_PER_ENDPOINT_FIELD_NUMBER;
    hash = (53 * hash) + java.lang.Float.floatToIntBits(getMaxRatePerEndpoint());
    hash = (37 * hash) + MAX_RATE_PER_INSTANCE_FIELD_NUMBER;
    hash = (53 * hash) + java.lang.Float.floatToIntBits(getMaxRatePerInstance());
    hash = (37 * hash) + MAX_UTILIZATION_FIELD_NUMBER;
    hash = (53 * hash) + java.lang.Float.floatToIntBits(getMaxUtilization());
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.google.cloud.compute.v1.Backend parseFrom(java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.Backend parseFrom(
      java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.Backend parseFrom(com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.Backend parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.Backend parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.Backend parseFrom(
      byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.Backend parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.Backend parseFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.Backend parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.Backend parseDelimitedFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.Backend parseFrom(
      com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.Backend parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() {
    return newBuilder();
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }

  public static Builder newBuilder(com.google.cloud.compute.v1.Backend prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   *
   *
   * <pre>
   * Message containing information of one individual backend.
   * </pre>
   *
   * Protobuf type {@code google.cloud.compute.v1.Backend}
   */
  public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
      implements
      // @@protoc_insertion_point(builder_implements:google.cloud.compute.v1.Backend)
      com.google.cloud.compute.v1.BackendOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_Backend_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_Backend_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.cloud.compute.v1.Backend.class,
              com.google.cloud.compute.v1.Backend.Builder.class);
    }

    // Construct using com.google.cloud.compute.v1.Backend.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }

    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
    }

    @java.lang.Override
    public Builder clear() {
      super.clear();
      balancingMode_ = 0;

      capacityScaler_ = 0F;

      description_ = "";

      failover_ = false;

      group_ = "";

      maxConnections_ = 0;

      maxConnectionsPerEndpoint_ = 0;

      maxConnectionsPerInstance_ = 0;

      maxRate_ = 0;

      maxRatePerEndpoint_ = 0F;

      maxRatePerInstance_ = 0F;

      maxUtilization_ = 0F;

      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_Backend_descriptor;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.Backend getDefaultInstanceForType() {
      return com.google.cloud.compute.v1.Backend.getDefaultInstance();
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.Backend build() {
      com.google.cloud.compute.v1.Backend result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.Backend buildPartial() {
      com.google.cloud.compute.v1.Backend result = new com.google.cloud.compute.v1.Backend(this);
      result.balancingMode_ = balancingMode_;
      result.capacityScaler_ = capacityScaler_;
      result.description_ = description_;
      result.failover_ = failover_;
      result.group_ = group_;
      result.maxConnections_ = maxConnections_;
      result.maxConnectionsPerEndpoint_ = maxConnectionsPerEndpoint_;
      result.maxConnectionsPerInstance_ = maxConnectionsPerInstance_;
      result.maxRate_ = maxRate_;
      result.maxRatePerEndpoint_ = maxRatePerEndpoint_;
      result.maxRatePerInstance_ = maxRatePerInstance_;
      result.maxUtilization_ = maxUtilization_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }

    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.setField(field, value);
    }

    @java.lang.Override
    public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }

    @java.lang.Override
    public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }

    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }

    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }

    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.google.cloud.compute.v1.Backend) {
        return mergeFrom((com.google.cloud.compute.v1.Backend) other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.google.cloud.compute.v1.Backend other) {
      if (other == com.google.cloud.compute.v1.Backend.getDefaultInstance()) return this;
      if (other.balancingMode_ != 0) {
        setBalancingModeValue(other.getBalancingModeValue());
      }
      if (other.getCapacityScaler() != 0F) {
        setCapacityScaler(other.getCapacityScaler());
      }
      if (!other.getDescription().isEmpty()) {
        description_ = other.description_;
        onChanged();
      }
      if (other.getFailover() != false) {
        setFailover(other.getFailover());
      }
      if (!other.getGroup().isEmpty()) {
        group_ = other.group_;
        onChanged();
      }
      if (other.getMaxConnections() != 0) {
        setMaxConnections(other.getMaxConnections());
      }
      if (other.getMaxConnectionsPerEndpoint() != 0) {
        setMaxConnectionsPerEndpoint(other.getMaxConnectionsPerEndpoint());
      }
      if (other.getMaxConnectionsPerInstance() != 0) {
        setMaxConnectionsPerInstance(other.getMaxConnectionsPerInstance());
      }
      if (other.getMaxRate() != 0) {
        setMaxRate(other.getMaxRate());
      }
      if (other.getMaxRatePerEndpoint() != 0F) {
        setMaxRatePerEndpoint(other.getMaxRatePerEndpoint());
      }
      if (other.getMaxRatePerInstance() != 0F) {
        setMaxRatePerInstance(other.getMaxRatePerInstance());
      }
      if (other.getMaxUtilization() != 0F) {
        setMaxUtilization(other.getMaxUtilization());
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      com.google.cloud.compute.v1.Backend parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (com.google.cloud.compute.v1.Backend) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }

    private int balancingMode_ = 0;
    /**
     *
     *
     * <pre>
     * Specifies the balancing mode for the backend.
     * When choosing a balancing mode, you need to consider the loadBalancingScheme, and protocol for the backend service, as well as the type of backend (instance group or NEG).
     * - If the load balancing mode is CONNECTION, then the load is spread based on how many concurrent connections the backend can handle.
     * You can use the CONNECTION balancing mode if the protocol for the backend service is SSL, TCP, or UDP.
     * If the loadBalancingScheme for the backend service is EXTERNAL (SSL Proxy and TCP Proxy load balancers), you must also specify exactly one of the following parameters: maxConnections (except for regional managed instance groups), maxConnectionsPerInstance, or maxConnectionsPerEndpoint.
     * If the loadBalancingScheme for the backend service is INTERNAL (internal TCP/UDP Load Balancers) or EXTERNAL  (Network Load Balancing), you cannot specify any additional parameters.
     * - If the load balancing mode is RATE, the load is spread based on the rate of HTTP requests per second (RPS).
     * You can use the RATE balancing mode if the protocol for the backend service is HTTP, HTTP2, or HTTPS. You must specify exactly one of the following parameters: maxRate (except for regional managed instance groups), maxRatePerInstance, or maxRatePerEndpoint.
     * - If the load balancing mode is UTILIZATION, the load is spread based on the backend utilization of instances in an instance group.
     * You can use the UTILIZATION balancing mode if the loadBalancingScheme of the backend service is EXTERNAL (except Network Load Balancing), INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED and the backends are instance groups. There are no restrictions on the backend service protocol.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Backend.BalancingMode balancing_mode = 161850761;</code>
     *
     * @return The enum numeric value on the wire for balancingMode.
     */
    @java.lang.Override
    public int getBalancingModeValue() {
      return balancingMode_;
    }
    /**
     *
     *
     * <pre>
     * Specifies the balancing mode for the backend.
     * When choosing a balancing mode, you need to consider the loadBalancingScheme, and protocol for the backend service, as well as the type of backend (instance group or NEG).
     * - If the load balancing mode is CONNECTION, then the load is spread based on how many concurrent connections the backend can handle.
     * You can use the CONNECTION balancing mode if the protocol for the backend service is SSL, TCP, or UDP.
     * If the loadBalancingScheme for the backend service is EXTERNAL (SSL Proxy and TCP Proxy load balancers), you must also specify exactly one of the following parameters: maxConnections (except for regional managed instance groups), maxConnectionsPerInstance, or maxConnectionsPerEndpoint.
     * If the loadBalancingScheme for the backend service is INTERNAL (internal TCP/UDP Load Balancers) or EXTERNAL  (Network Load Balancing), you cannot specify any additional parameters.
     * - If the load balancing mode is RATE, the load is spread based on the rate of HTTP requests per second (RPS).
     * You can use the RATE balancing mode if the protocol for the backend service is HTTP, HTTP2, or HTTPS. You must specify exactly one of the following parameters: maxRate (except for regional managed instance groups), maxRatePerInstance, or maxRatePerEndpoint.
     * - If the load balancing mode is UTILIZATION, the load is spread based on the backend utilization of instances in an instance group.
     * You can use the UTILIZATION balancing mode if the loadBalancingScheme of the backend service is EXTERNAL (except Network Load Balancing), INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED and the backends are instance groups. There are no restrictions on the backend service protocol.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Backend.BalancingMode balancing_mode = 161850761;</code>
     *
     * @param value The enum numeric value on the wire for balancingMode to set.
     * @return This builder for chaining.
     */
    public Builder setBalancingModeValue(int value) {

      balancingMode_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies the balancing mode for the backend.
     * When choosing a balancing mode, you need to consider the loadBalancingScheme, and protocol for the backend service, as well as the type of backend (instance group or NEG).
     * - If the load balancing mode is CONNECTION, then the load is spread based on how many concurrent connections the backend can handle.
     * You can use the CONNECTION balancing mode if the protocol for the backend service is SSL, TCP, or UDP.
     * If the loadBalancingScheme for the backend service is EXTERNAL (SSL Proxy and TCP Proxy load balancers), you must also specify exactly one of the following parameters: maxConnections (except for regional managed instance groups), maxConnectionsPerInstance, or maxConnectionsPerEndpoint.
     * If the loadBalancingScheme for the backend service is INTERNAL (internal TCP/UDP Load Balancers) or EXTERNAL  (Network Load Balancing), you cannot specify any additional parameters.
     * - If the load balancing mode is RATE, the load is spread based on the rate of HTTP requests per second (RPS).
     * You can use the RATE balancing mode if the protocol for the backend service is HTTP, HTTP2, or HTTPS. You must specify exactly one of the following parameters: maxRate (except for regional managed instance groups), maxRatePerInstance, or maxRatePerEndpoint.
     * - If the load balancing mode is UTILIZATION, the load is spread based on the backend utilization of instances in an instance group.
     * You can use the UTILIZATION balancing mode if the loadBalancingScheme of the backend service is EXTERNAL (except Network Load Balancing), INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED and the backends are instance groups. There are no restrictions on the backend service protocol.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Backend.BalancingMode balancing_mode = 161850761;</code>
     *
     * @return The balancingMode.
     */
    @java.lang.Override
    public com.google.cloud.compute.v1.Backend.BalancingMode getBalancingMode() {
      @SuppressWarnings("deprecation")
      com.google.cloud.compute.v1.Backend.BalancingMode result =
          com.google.cloud.compute.v1.Backend.BalancingMode.valueOf(balancingMode_);
      return result == null
          ? com.google.cloud.compute.v1.Backend.BalancingMode.UNRECOGNIZED
          : result;
    }
    /**
     *
     *
     * <pre>
     * Specifies the balancing mode for the backend.
     * When choosing a balancing mode, you need to consider the loadBalancingScheme, and protocol for the backend service, as well as the type of backend (instance group or NEG).
     * - If the load balancing mode is CONNECTION, then the load is spread based on how many concurrent connections the backend can handle.
     * You can use the CONNECTION balancing mode if the protocol for the backend service is SSL, TCP, or UDP.
     * If the loadBalancingScheme for the backend service is EXTERNAL (SSL Proxy and TCP Proxy load balancers), you must also specify exactly one of the following parameters: maxConnections (except for regional managed instance groups), maxConnectionsPerInstance, or maxConnectionsPerEndpoint.
     * If the loadBalancingScheme for the backend service is INTERNAL (internal TCP/UDP Load Balancers) or EXTERNAL  (Network Load Balancing), you cannot specify any additional parameters.
     * - If the load balancing mode is RATE, the load is spread based on the rate of HTTP requests per second (RPS).
     * You can use the RATE balancing mode if the protocol for the backend service is HTTP, HTTP2, or HTTPS. You must specify exactly one of the following parameters: maxRate (except for regional managed instance groups), maxRatePerInstance, or maxRatePerEndpoint.
     * - If the load balancing mode is UTILIZATION, the load is spread based on the backend utilization of instances in an instance group.
     * You can use the UTILIZATION balancing mode if the loadBalancingScheme of the backend service is EXTERNAL (except Network Load Balancing), INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED and the backends are instance groups. There are no restrictions on the backend service protocol.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Backend.BalancingMode balancing_mode = 161850761;</code>
     *
     * @param value The balancingMode to set.
     * @return This builder for chaining.
     */
    public Builder setBalancingMode(com.google.cloud.compute.v1.Backend.BalancingMode value) {
      if (value == null) {
        throw new NullPointerException();
      }

      balancingMode_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies the balancing mode for the backend.
     * When choosing a balancing mode, you need to consider the loadBalancingScheme, and protocol for the backend service, as well as the type of backend (instance group or NEG).
     * - If the load balancing mode is CONNECTION, then the load is spread based on how many concurrent connections the backend can handle.
     * You can use the CONNECTION balancing mode if the protocol for the backend service is SSL, TCP, or UDP.
     * If the loadBalancingScheme for the backend service is EXTERNAL (SSL Proxy and TCP Proxy load balancers), you must also specify exactly one of the following parameters: maxConnections (except for regional managed instance groups), maxConnectionsPerInstance, or maxConnectionsPerEndpoint.
     * If the loadBalancingScheme for the backend service is INTERNAL (internal TCP/UDP Load Balancers) or EXTERNAL  (Network Load Balancing), you cannot specify any additional parameters.
     * - If the load balancing mode is RATE, the load is spread based on the rate of HTTP requests per second (RPS).
     * You can use the RATE balancing mode if the protocol for the backend service is HTTP, HTTP2, or HTTPS. You must specify exactly one of the following parameters: maxRate (except for regional managed instance groups), maxRatePerInstance, or maxRatePerEndpoint.
     * - If the load balancing mode is UTILIZATION, the load is spread based on the backend utilization of instances in an instance group.
     * You can use the UTILIZATION balancing mode if the loadBalancingScheme of the backend service is EXTERNAL (except Network Load Balancing), INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED and the backends are instance groups. There are no restrictions on the backend service protocol.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Backend.BalancingMode balancing_mode = 161850761;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearBalancingMode() {

      balancingMode_ = 0;
      onChanged();
      return this;
    }

    private float capacityScaler_;
    /**
     *
     *
     * <pre>
     * A multiplier applied to the group's maximum servicing capacity (based on UTILIZATION, RATE or CONNECTION). Default value is 1, which means the group will serve up to 100% of its configured capacity (depending on balancingMode). A setting of 0 means the group is completely drained, offering 0% of its available capacity. Valid range is 0.0 and [0.1,1.0]. You cannot configure a setting larger than 0 and smaller than 0.1. You cannot configure a setting of 0 when there is only one backend attached to the backend service.
     * This cannot be used for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>float capacity_scaler = 47522701;</code>
     *
     * @return The capacityScaler.
     */
    @java.lang.Override
    public float getCapacityScaler() {
      return capacityScaler_;
    }
    /**
     *
     *
     * <pre>
     * A multiplier applied to the group's maximum servicing capacity (based on UTILIZATION, RATE or CONNECTION). Default value is 1, which means the group will serve up to 100% of its configured capacity (depending on balancingMode). A setting of 0 means the group is completely drained, offering 0% of its available capacity. Valid range is 0.0 and [0.1,1.0]. You cannot configure a setting larger than 0 and smaller than 0.1. You cannot configure a setting of 0 when there is only one backend attached to the backend service.
     * This cannot be used for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>float capacity_scaler = 47522701;</code>
     *
     * @param value The capacityScaler to set.
     * @return This builder for chaining.
     */
    public Builder setCapacityScaler(float value) {

      capacityScaler_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * A multiplier applied to the group's maximum servicing capacity (based on UTILIZATION, RATE or CONNECTION). Default value is 1, which means the group will serve up to 100% of its configured capacity (depending on balancingMode). A setting of 0 means the group is completely drained, offering 0% of its available capacity. Valid range is 0.0 and [0.1,1.0]. You cannot configure a setting larger than 0 and smaller than 0.1. You cannot configure a setting of 0 when there is only one backend attached to the backend service.
     * This cannot be used for Internal TCP/UDP Load Balancing and Network Load Balancing.
     * </pre>
     *
     * <code>float capacity_scaler = 47522701;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearCapacityScaler() {

      capacityScaler_ = 0F;
      onChanged();
      return this;
    }

    private java.lang.Object description_ = "";
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 154502140;</code>
     *
     * @return The description.
     */
    public java.lang.String getDescription() {
      java.lang.Object ref = description_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        description_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 154502140;</code>
     *
     * @return The bytes for description.
     */
    public com.google.protobuf.ByteString getDescriptionBytes() {
      java.lang.Object ref = description_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        description_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 154502140;</code>
     *
     * @param value The description to set.
     * @return This builder for chaining.
     */
    public Builder setDescription(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }

      description_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 154502140;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearDescription() {

      description_ = getDefaultInstance().getDescription();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * An optional description of this resource. Provide this property when you create the resource.
     * </pre>
     *
     * <code>string description = 154502140;</code>
     *
     * @param value The bytes for description to set.
     * @return This builder for chaining.
     */
    public Builder setDescriptionBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);

      description_ = value;
      onChanged();
      return this;
    }

    private boolean failover_;
    /**
     *
     *
     * <pre>
     * This field designates whether this is a failover backend. More than one failover backend can be configured for a given BackendService.
     * </pre>
     *
     * <code>bool failover = 138892530;</code>
     *
     * @return The failover.
     */
    @java.lang.Override
    public boolean getFailover() {
      return failover_;
    }
    /**
     *
     *
     * <pre>
     * This field designates whether this is a failover backend. More than one failover backend can be configured for a given BackendService.
     * </pre>
     *
     * <code>bool failover = 138892530;</code>
     *
     * @param value The failover to set.
     * @return This builder for chaining.
     */
    public Builder setFailover(boolean value) {

      failover_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * This field designates whether this is a failover backend. More than one failover backend can be configured for a given BackendService.
     * </pre>
     *
     * <code>bool failover = 138892530;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearFailover() {

      failover_ = false;
      onChanged();
      return this;
    }

    private java.lang.Object group_ = "";
    /**
     *
     *
     * <pre>
     * The fully-qualified URL of an instance group or network endpoint group (NEG) resource. The type of backend that a backend service supports depends on the backend service's loadBalancingScheme.
     * - When the loadBalancingScheme for the backend service is EXTERNAL (except Network Load Balancing),  INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED , the backend can be either an instance group or a NEG. The backends on the backend service must be either all instance groups or all NEGs. You cannot mix instance group and NEG backends on the same backend service.
     * - When the loadBalancingScheme for the backend service is EXTERNAL for Network Load Balancing or INTERNAL for Internal TCP/UDP Load Balancing, the backend must be an instance group. NEGs are not supported.
     * For regional services, the backend must be in the same region as the backend service.
     * You must use the fully-qualified URL (starting with https://www.googleapis.com/) to specify the instance group or NEG. Partial URLs are not supported.
     * </pre>
     *
     * <code>string group = 98629247;</code>
     *
     * @return The group.
     */
    public java.lang.String getGroup() {
      java.lang.Object ref = group_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        group_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * The fully-qualified URL of an instance group or network endpoint group (NEG) resource. The type of backend that a backend service supports depends on the backend service's loadBalancingScheme.
     * - When the loadBalancingScheme for the backend service is EXTERNAL (except Network Load Balancing),  INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED , the backend can be either an instance group or a NEG. The backends on the backend service must be either all instance groups or all NEGs. You cannot mix instance group and NEG backends on the same backend service.
     * - When the loadBalancingScheme for the backend service is EXTERNAL for Network Load Balancing or INTERNAL for Internal TCP/UDP Load Balancing, the backend must be an instance group. NEGs are not supported.
     * For regional services, the backend must be in the same region as the backend service.
     * You must use the fully-qualified URL (starting with https://www.googleapis.com/) to specify the instance group or NEG. Partial URLs are not supported.
     * </pre>
     *
     * <code>string group = 98629247;</code>
     *
     * @return The bytes for group.
     */
    public com.google.protobuf.ByteString getGroupBytes() {
      java.lang.Object ref = group_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        group_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * The fully-qualified URL of an instance group or network endpoint group (NEG) resource. The type of backend that a backend service supports depends on the backend service's loadBalancingScheme.
     * - When the loadBalancingScheme for the backend service is EXTERNAL (except Network Load Balancing),  INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED , the backend can be either an instance group or a NEG. The backends on the backend service must be either all instance groups or all NEGs. You cannot mix instance group and NEG backends on the same backend service.
     * - When the loadBalancingScheme for the backend service is EXTERNAL for Network Load Balancing or INTERNAL for Internal TCP/UDP Load Balancing, the backend must be an instance group. NEGs are not supported.
     * For regional services, the backend must be in the same region as the backend service.
     * You must use the fully-qualified URL (starting with https://www.googleapis.com/) to specify the instance group or NEG. Partial URLs are not supported.
     * </pre>
     *
     * <code>string group = 98629247;</code>
     *
     * @param value The group to set.
     * @return This builder for chaining.
     */
    public Builder setGroup(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }

      group_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The fully-qualified URL of an instance group or network endpoint group (NEG) resource. The type of backend that a backend service supports depends on the backend service's loadBalancingScheme.
     * - When the loadBalancingScheme for the backend service is EXTERNAL (except Network Load Balancing),  INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED , the backend can be either an instance group or a NEG. The backends on the backend service must be either all instance groups or all NEGs. You cannot mix instance group and NEG backends on the same backend service.
     * - When the loadBalancingScheme for the backend service is EXTERNAL for Network Load Balancing or INTERNAL for Internal TCP/UDP Load Balancing, the backend must be an instance group. NEGs are not supported.
     * For regional services, the backend must be in the same region as the backend service.
     * You must use the fully-qualified URL (starting with https://www.googleapis.com/) to specify the instance group or NEG. Partial URLs are not supported.
     * </pre>
     *
     * <code>string group = 98629247;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearGroup() {

      group_ = getDefaultInstance().getGroup();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The fully-qualified URL of an instance group or network endpoint group (NEG) resource. The type of backend that a backend service supports depends on the backend service's loadBalancingScheme.
     * - When the loadBalancingScheme for the backend service is EXTERNAL (except Network Load Balancing),  INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED , the backend can be either an instance group or a NEG. The backends on the backend service must be either all instance groups or all NEGs. You cannot mix instance group and NEG backends on the same backend service.
     * - When the loadBalancingScheme for the backend service is EXTERNAL for Network Load Balancing or INTERNAL for Internal TCP/UDP Load Balancing, the backend must be an instance group. NEGs are not supported.
     * For regional services, the backend must be in the same region as the backend service.
     * You must use the fully-qualified URL (starting with https://www.googleapis.com/) to specify the instance group or NEG. Partial URLs are not supported.
     * </pre>
     *
     * <code>string group = 98629247;</code>
     *
     * @param value The bytes for group to set.
     * @return This builder for chaining.
     */
    public Builder setGroupBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);

      group_ = value;
      onChanged();
      return this;
    }

    private int maxConnections_;
    /**
     *
     *
     * <pre>
     * Defines a target maximum number of simultaneous connections that the backend can handle. Valid for network endpoint group and instance group backends (except for regional managed instance groups). If the backend's balancingMode is UTILIZATION, this is an optional parameter. If the backend's balancingMode is CONNECTION, and backend is attached to a backend service whose loadBalancingScheme is EXTERNAL (except Network Load Balancing), you must specify either this parameter, maxConnectionsPerInstance, or maxConnectionsPerEndpoint.
     * Not available if the backend's balancingMode is RATE. Cannot be specified for Network Load Balancing or Internal TCP/UDP Load Balancing, even though those load balancers require a balancing mode of CONNECTION.
     * </pre>
     *
     * <code>int32 max_connections = 110652154;</code>
     *
     * @return The maxConnections.
     */
    @java.lang.Override
    public int getMaxConnections() {
      return maxConnections_;
    }
    /**
     *
     *
     * <pre>
     * Defines a target maximum number of simultaneous connections that the backend can handle. Valid for network endpoint group and instance group backends (except for regional managed instance groups). If the backend's balancingMode is UTILIZATION, this is an optional parameter. If the backend's balancingMode is CONNECTION, and backend is attached to a backend service whose loadBalancingScheme is EXTERNAL (except Network Load Balancing), you must specify either this parameter, maxConnectionsPerInstance, or maxConnectionsPerEndpoint.
     * Not available if the backend's balancingMode is RATE. Cannot be specified for Network Load Balancing or Internal TCP/UDP Load Balancing, even though those load balancers require a balancing mode of CONNECTION.
     * </pre>
     *
     * <code>int32 max_connections = 110652154;</code>
     *
     * @param value The maxConnections to set.
     * @return This builder for chaining.
     */
    public Builder setMaxConnections(int value) {

      maxConnections_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Defines a target maximum number of simultaneous connections that the backend can handle. Valid for network endpoint group and instance group backends (except for regional managed instance groups). If the backend's balancingMode is UTILIZATION, this is an optional parameter. If the backend's balancingMode is CONNECTION, and backend is attached to a backend service whose loadBalancingScheme is EXTERNAL (except Network Load Balancing), you must specify either this parameter, maxConnectionsPerInstance, or maxConnectionsPerEndpoint.
     * Not available if the backend's balancingMode is RATE. Cannot be specified for Network Load Balancing or Internal TCP/UDP Load Balancing, even though those load balancers require a balancing mode of CONNECTION.
     * </pre>
     *
     * <code>int32 max_connections = 110652154;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearMaxConnections() {

      maxConnections_ = 0;
      onChanged();
      return this;
    }

    private int maxConnectionsPerEndpoint_;
    /**
     *
     *
     * <pre>
     * Defines a target maximum number of simultaneous connections for an endpoint of a NEG. This is multiplied by the number of endpoints in the NEG to implicitly calculate a maximum number of target maximum simultaneous connections for the NEG. If the backend's balancingMode is CONNECTION, and backend is attached to a backend service whose loadBalancingScheme is EXTERNAL (except Network Load Balancing), you must specify either this parameter, maxConnections, or maxConnectionsPerInstance.
     * Not available if the backend's balancingMode is RATE. Cannot be specified for Network Load Balancing or Internal TCP/UDP Load Balancing, even though those load balancers require a balancing mode of CONNECTION.
     * </pre>
     *
     * <code>int32 max_connections_per_endpoint = 216904604;</code>
     *
     * @return The maxConnectionsPerEndpoint.
     */
    @java.lang.Override
    public int getMaxConnectionsPerEndpoint() {
      return maxConnectionsPerEndpoint_;
    }
    /**
     *
     *
     * <pre>
     * Defines a target maximum number of simultaneous connections for an endpoint of a NEG. This is multiplied by the number of endpoints in the NEG to implicitly calculate a maximum number of target maximum simultaneous connections for the NEG. If the backend's balancingMode is CONNECTION, and backend is attached to a backend service whose loadBalancingScheme is EXTERNAL (except Network Load Balancing), you must specify either this parameter, maxConnections, or maxConnectionsPerInstance.
     * Not available if the backend's balancingMode is RATE. Cannot be specified for Network Load Balancing or Internal TCP/UDP Load Balancing, even though those load balancers require a balancing mode of CONNECTION.
     * </pre>
     *
     * <code>int32 max_connections_per_endpoint = 216904604;</code>
     *
     * @param value The maxConnectionsPerEndpoint to set.
     * @return This builder for chaining.
     */
    public Builder setMaxConnectionsPerEndpoint(int value) {

      maxConnectionsPerEndpoint_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Defines a target maximum number of simultaneous connections for an endpoint of a NEG. This is multiplied by the number of endpoints in the NEG to implicitly calculate a maximum number of target maximum simultaneous connections for the NEG. If the backend's balancingMode is CONNECTION, and backend is attached to a backend service whose loadBalancingScheme is EXTERNAL (except Network Load Balancing), you must specify either this parameter, maxConnections, or maxConnectionsPerInstance.
     * Not available if the backend's balancingMode is RATE. Cannot be specified for Network Load Balancing or Internal TCP/UDP Load Balancing, even though those load balancers require a balancing mode of CONNECTION.
     * </pre>
     *
     * <code>int32 max_connections_per_endpoint = 216904604;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearMaxConnectionsPerEndpoint() {

      maxConnectionsPerEndpoint_ = 0;
      onChanged();
      return this;
    }

    private int maxConnectionsPerInstance_;
    /**
     *
     *
     * <pre>
     * Defines a target maximum number of simultaneous connections for a single VM in a backend instance group. This is multiplied by the number of instances in the instance group to implicitly calculate a target maximum number of simultaneous connections for the whole instance group. If the backend's balancingMode is UTILIZATION, this is an optional parameter. If the backend's balancingMode is CONNECTION, and backend is attached to a backend service whose loadBalancingScheme is EXTERNAL (except Network Load Balancing), you must specify either this parameter,  maxConnections, or maxConnectionsPerEndpoint.
     * Not available if the backend's balancingMode is RATE. Cannot be specified for Network Load Balancing or Internal TCP/UDP Load Balancing, even though those load balancers require a balancing mode of CONNECTION.
     * </pre>
     *
     * <code>int32 max_connections_per_instance = 104671900;</code>
     *
     * @return The maxConnectionsPerInstance.
     */
    @java.lang.Override
    public int getMaxConnectionsPerInstance() {
      return maxConnectionsPerInstance_;
    }
    /**
     *
     *
     * <pre>
     * Defines a target maximum number of simultaneous connections for a single VM in a backend instance group. This is multiplied by the number of instances in the instance group to implicitly calculate a target maximum number of simultaneous connections for the whole instance group. If the backend's balancingMode is UTILIZATION, this is an optional parameter. If the backend's balancingMode is CONNECTION, and backend is attached to a backend service whose loadBalancingScheme is EXTERNAL (except Network Load Balancing), you must specify either this parameter,  maxConnections, or maxConnectionsPerEndpoint.
     * Not available if the backend's balancingMode is RATE. Cannot be specified for Network Load Balancing or Internal TCP/UDP Load Balancing, even though those load balancers require a balancing mode of CONNECTION.
     * </pre>
     *
     * <code>int32 max_connections_per_instance = 104671900;</code>
     *
     * @param value The maxConnectionsPerInstance to set.
     * @return This builder for chaining.
     */
    public Builder setMaxConnectionsPerInstance(int value) {

      maxConnectionsPerInstance_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Defines a target maximum number of simultaneous connections for a single VM in a backend instance group. This is multiplied by the number of instances in the instance group to implicitly calculate a target maximum number of simultaneous connections for the whole instance group. If the backend's balancingMode is UTILIZATION, this is an optional parameter. If the backend's balancingMode is CONNECTION, and backend is attached to a backend service whose loadBalancingScheme is EXTERNAL (except Network Load Balancing), you must specify either this parameter,  maxConnections, or maxConnectionsPerEndpoint.
     * Not available if the backend's balancingMode is RATE. Cannot be specified for Network Load Balancing or Internal TCP/UDP Load Balancing, even though those load balancers require a balancing mode of CONNECTION.
     * </pre>
     *
     * <code>int32 max_connections_per_instance = 104671900;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearMaxConnectionsPerInstance() {

      maxConnectionsPerInstance_ = 0;
      onChanged();
      return this;
    }

    private int maxRate_;
    /**
     *
     *
     * <pre>
     * Defines a maximum number of HTTP requests per second (RPS) that the backend can handle. Valid for network endpoint group and instance group backends (except for regional managed instance groups). Must not be defined if the backend is a managed instance group that uses autoscaling based on load balancing.
     * If the backend's balancingMode is UTILIZATION, this is an optional parameter. If the backend's balancingMode is RATE, you must specify maxRate, maxRatePerInstance, or maxRatePerEndpoint.
     * Not available if the backend's balancingMode is CONNECTION.
     * </pre>
     *
     * <code>int32 max_rate = 139599579;</code>
     *
     * @return The maxRate.
     */
    @java.lang.Override
    public int getMaxRate() {
      return maxRate_;
    }
    /**
     *
     *
     * <pre>
     * Defines a maximum number of HTTP requests per second (RPS) that the backend can handle. Valid for network endpoint group and instance group backends (except for regional managed instance groups). Must not be defined if the backend is a managed instance group that uses autoscaling based on load balancing.
     * If the backend's balancingMode is UTILIZATION, this is an optional parameter. If the backend's balancingMode is RATE, you must specify maxRate, maxRatePerInstance, or maxRatePerEndpoint.
     * Not available if the backend's balancingMode is CONNECTION.
     * </pre>
     *
     * <code>int32 max_rate = 139599579;</code>
     *
     * @param value The maxRate to set.
     * @return This builder for chaining.
     */
    public Builder setMaxRate(int value) {

      maxRate_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Defines a maximum number of HTTP requests per second (RPS) that the backend can handle. Valid for network endpoint group and instance group backends (except for regional managed instance groups). Must not be defined if the backend is a managed instance group that uses autoscaling based on load balancing.
     * If the backend's balancingMode is UTILIZATION, this is an optional parameter. If the backend's balancingMode is RATE, you must specify maxRate, maxRatePerInstance, or maxRatePerEndpoint.
     * Not available if the backend's balancingMode is CONNECTION.
     * </pre>
     *
     * <code>int32 max_rate = 139599579;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearMaxRate() {

      maxRate_ = 0;
      onChanged();
      return this;
    }

    private float maxRatePerEndpoint_;
    /**
     *
     *
     * <pre>
     * Defines a maximum target for requests per second (RPS) for an endpoint of a NEG. This is multiplied by the number of endpoints in the NEG to implicitly calculate a target maximum rate for the NEG.
     * If the backend's balancingMode is RATE, you must specify either this parameter, maxRate (except for regional managed instance groups), or maxRatePerInstance.
     * Not available if the backend's balancingMode is CONNECTION.
     * </pre>
     *
     * <code>float max_rate_per_endpoint = 129832283;</code>
     *
     * @return The maxRatePerEndpoint.
     */
    @java.lang.Override
    public float getMaxRatePerEndpoint() {
      return maxRatePerEndpoint_;
    }
    /**
     *
     *
     * <pre>
     * Defines a maximum target for requests per second (RPS) for an endpoint of a NEG. This is multiplied by the number of endpoints in the NEG to implicitly calculate a target maximum rate for the NEG.
     * If the backend's balancingMode is RATE, you must specify either this parameter, maxRate (except for regional managed instance groups), or maxRatePerInstance.
     * Not available if the backend's balancingMode is CONNECTION.
     * </pre>
     *
     * <code>float max_rate_per_endpoint = 129832283;</code>
     *
     * @param value The maxRatePerEndpoint to set.
     * @return This builder for chaining.
     */
    public Builder setMaxRatePerEndpoint(float value) {

      maxRatePerEndpoint_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Defines a maximum target for requests per second (RPS) for an endpoint of a NEG. This is multiplied by the number of endpoints in the NEG to implicitly calculate a target maximum rate for the NEG.
     * If the backend's balancingMode is RATE, you must specify either this parameter, maxRate (except for regional managed instance groups), or maxRatePerInstance.
     * Not available if the backend's balancingMode is CONNECTION.
     * </pre>
     *
     * <code>float max_rate_per_endpoint = 129832283;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearMaxRatePerEndpoint() {

      maxRatePerEndpoint_ = 0F;
      onChanged();
      return this;
    }

    private float maxRatePerInstance_;
    /**
     *
     *
     * <pre>
     * Defines a maximum target for requests per second (RPS) for a single VM in a backend instance group. This is multiplied by the number of instances in the instance group to implicitly calculate a target maximum rate for the whole instance group.
     * If the backend's balancingMode is UTILIZATION, this is an optional parameter. If the backend's balancingMode is RATE, you must specify either this parameter, maxRate (except for regional managed instance groups), or maxRatePerEndpoint.
     * Not available if the backend's balancingMode is CONNECTION.
     * </pre>
     *
     * <code>float max_rate_per_instance = 17599579;</code>
     *
     * @return The maxRatePerInstance.
     */
    @java.lang.Override
    public float getMaxRatePerInstance() {
      return maxRatePerInstance_;
    }
    /**
     *
     *
     * <pre>
     * Defines a maximum target for requests per second (RPS) for a single VM in a backend instance group. This is multiplied by the number of instances in the instance group to implicitly calculate a target maximum rate for the whole instance group.
     * If the backend's balancingMode is UTILIZATION, this is an optional parameter. If the backend's balancingMode is RATE, you must specify either this parameter, maxRate (except for regional managed instance groups), or maxRatePerEndpoint.
     * Not available if the backend's balancingMode is CONNECTION.
     * </pre>
     *
     * <code>float max_rate_per_instance = 17599579;</code>
     *
     * @param value The maxRatePerInstance to set.
     * @return This builder for chaining.
     */
    public Builder setMaxRatePerInstance(float value) {

      maxRatePerInstance_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Defines a maximum target for requests per second (RPS) for a single VM in a backend instance group. This is multiplied by the number of instances in the instance group to implicitly calculate a target maximum rate for the whole instance group.
     * If the backend's balancingMode is UTILIZATION, this is an optional parameter. If the backend's balancingMode is RATE, you must specify either this parameter, maxRate (except for regional managed instance groups), or maxRatePerEndpoint.
     * Not available if the backend's balancingMode is CONNECTION.
     * </pre>
     *
     * <code>float max_rate_per_instance = 17599579;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearMaxRatePerInstance() {

      maxRatePerInstance_ = 0F;
      onChanged();
      return this;
    }

    private float maxUtilization_;
    /**
     *
     *
     * <pre>
     * Defines the maximum average backend utilization of a backend VM in an instance group. The valid range is [0.0, 1.0]. This is an optional parameter if the backend's balancingMode is UTILIZATION.
     * This parameter can be used in conjunction with maxRate, maxRatePerInstance, maxConnections (except for regional managed instance groups), or maxConnectionsPerInstance.
     * </pre>
     *
     * <code>float max_utilization = 148192199;</code>
     *
     * @return The maxUtilization.
     */
    @java.lang.Override
    public float getMaxUtilization() {
      return maxUtilization_;
    }
    /**
     *
     *
     * <pre>
     * Defines the maximum average backend utilization of a backend VM in an instance group. The valid range is [0.0, 1.0]. This is an optional parameter if the backend's balancingMode is UTILIZATION.
     * This parameter can be used in conjunction with maxRate, maxRatePerInstance, maxConnections (except for regional managed instance groups), or maxConnectionsPerInstance.
     * </pre>
     *
     * <code>float max_utilization = 148192199;</code>
     *
     * @param value The maxUtilization to set.
     * @return This builder for chaining.
     */
    public Builder setMaxUtilization(float value) {

      maxUtilization_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Defines the maximum average backend utilization of a backend VM in an instance group. The valid range is [0.0, 1.0]. This is an optional parameter if the backend's balancingMode is UTILIZATION.
     * This parameter can be used in conjunction with maxRate, maxRatePerInstance, maxConnections (except for regional managed instance groups), or maxConnectionsPerInstance.
     * </pre>
     *
     * <code>float max_utilization = 148192199;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearMaxUtilization() {

      maxUtilization_ = 0F;
      onChanged();
      return this;
    }

    @java.lang.Override
    public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }

    // @@protoc_insertion_point(builder_scope:google.cloud.compute.v1.Backend)
  }

  // @@protoc_insertion_point(class_scope:google.cloud.compute.v1.Backend)
  private static final com.google.cloud.compute.v1.Backend DEFAULT_INSTANCE;

  static {
    DEFAULT_INSTANCE = new com.google.cloud.compute.v1.Backend();
  }

  public static com.google.cloud.compute.v1.Backend getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<Backend> PARSER =
      new com.google.protobuf.AbstractParser<Backend>() {
        @java.lang.Override
        public Backend parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new Backend(input, extensionRegistry);
        }
      };

  public static com.google.protobuf.Parser<Backend> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<Backend> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.cloud.compute.v1.Backend getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }
}
