/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/compute/v1/compute.proto

package com.google.cloud.compute.v1;

/**
 *
 *
 * <pre>
 * Settings controlling the eviction of unhealthy hosts from the load balancing pool for the backend service.
 * </pre>
 *
 * Protobuf type {@code google.cloud.compute.v1.OutlierDetection}
 */
public final class OutlierDetection extends com.google.protobuf.GeneratedMessageV3
    implements
    // @@protoc_insertion_point(message_implements:google.cloud.compute.v1.OutlierDetection)
    OutlierDetectionOrBuilder {
  private static final long serialVersionUID = 0L;
  // Use OutlierDetection.newBuilder() to construct.
  private OutlierDetection(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }

  private OutlierDetection() {}

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
    return new OutlierDetection();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
  }

  private OutlierDetection(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 103919208:
            {
              successRateRequestVolume_ = input.readInt32();
              break;
            }
          case 147495104:
            {
              maxEjectionPercent_ = input.readInt32();
              break;
            }
          case 268379690:
            {
              com.google.cloud.compute.v1.Duration.Builder subBuilder = null;
              if (interval_ != null) {
                subBuilder = interval_.toBuilder();
              }
              interval_ =
                  input.readMessage(
                      com.google.cloud.compute.v1.Duration.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(interval_);
                interval_ = subBuilder.buildPartial();
              }

              break;
            }
          case 647978042:
            {
              com.google.cloud.compute.v1.Duration.Builder subBuilder = null;
              if (baseEjectionTime_ != null) {
                subBuilder = baseEjectionTime_.toBuilder();
              }
              baseEjectionTime_ =
                  input.readMessage(
                      com.google.cloud.compute.v1.Duration.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(baseEjectionTime_);
                baseEjectionTime_ = subBuilder.buildPartial();
              }

              break;
            }
          case 950062336:
            {
              consecutiveErrors_ = input.readInt32();
              break;
            }
          case 1008041680:
            {
              enforcingConsecutiveGatewayFailure_ = input.readInt32();
              break;
            }
          case 1192550352:
            {
              consecutiveGatewayFailure_ = input.readInt32();
              break;
            }
          case 1397886184:
            {
              successRateStdevFactor_ = input.readInt32();
              break;
            }
          case 1556069856:
            {
              enforcingSuccessRate_ = input.readInt32();
              break;
            }
          case 1705070080:
            {
              enforcingConsecutiveErrors_ = input.readInt32();
              break;
            }
          case 2058651576:
            {
              successRateMinimumHosts_ = input.readInt32();
              break;
            }
          default:
            {
              if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
    } finally {
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }

  public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_OutlierDetection_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_OutlierDetection_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.google.cloud.compute.v1.OutlierDetection.class,
            com.google.cloud.compute.v1.OutlierDetection.Builder.class);
  }

  public static final int BASE_EJECTION_TIME_FIELD_NUMBER = 80997255;
  private com.google.cloud.compute.v1.Duration baseEjectionTime_;
  /**
   *
   *
   * <pre>
   * The base time that a host is ejected for. The real ejection time is equal to the base ejection time multiplied by the number of times the host has been ejected. Defaults to 30000ms or 30s.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.Duration base_ejection_time = 80997255;</code>
   *
   * @return Whether the baseEjectionTime field is set.
   */
  @java.lang.Override
  public boolean hasBaseEjectionTime() {
    return baseEjectionTime_ != null;
  }
  /**
   *
   *
   * <pre>
   * The base time that a host is ejected for. The real ejection time is equal to the base ejection time multiplied by the number of times the host has been ejected. Defaults to 30000ms or 30s.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.Duration base_ejection_time = 80997255;</code>
   *
   * @return The baseEjectionTime.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.Duration getBaseEjectionTime() {
    return baseEjectionTime_ == null
        ? com.google.cloud.compute.v1.Duration.getDefaultInstance()
        : baseEjectionTime_;
  }
  /**
   *
   *
   * <pre>
   * The base time that a host is ejected for. The real ejection time is equal to the base ejection time multiplied by the number of times the host has been ejected. Defaults to 30000ms or 30s.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.Duration base_ejection_time = 80997255;</code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.DurationOrBuilder getBaseEjectionTimeOrBuilder() {
    return getBaseEjectionTime();
  }

  public static final int CONSECUTIVE_ERRORS_FIELD_NUMBER = 118757792;
  private int consecutiveErrors_;
  /**
   *
   *
   * <pre>
   * Number of errors before a host is ejected from the connection pool. When the backend host is accessed over HTTP, a 5xx return code qualifies as an error. Defaults to 5.
   * </pre>
   *
   * <code>int32 consecutive_errors = 118757792;</code>
   *
   * @return The consecutiveErrors.
   */
  @java.lang.Override
  public int getConsecutiveErrors() {
    return consecutiveErrors_;
  }

  public static final int CONSECUTIVE_GATEWAY_FAILURE_FIELD_NUMBER = 149068794;
  private int consecutiveGatewayFailure_;
  /**
   *
   *
   * <pre>
   * The number of consecutive gateway failures (502, 503, 504 status or connection errors that are mapped to one of those status codes) before a consecutive gateway failure ejection occurs. Defaults to 3.
   * </pre>
   *
   * <code>int32 consecutive_gateway_failure = 149068794;</code>
   *
   * @return The consecutiveGatewayFailure.
   */
  @java.lang.Override
  public int getConsecutiveGatewayFailure() {
    return consecutiveGatewayFailure_;
  }

  public static final int ENFORCING_CONSECUTIVE_ERRORS_FIELD_NUMBER = 213133760;
  private int enforcingConsecutiveErrors_;
  /**
   *
   *
   * <pre>
   * The percentage chance that a host will be actually ejected when an outlier status is detected through consecutive 5xx. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 0.
   * </pre>
   *
   * <code>int32 enforcing_consecutive_errors = 213133760;</code>
   *
   * @return The enforcingConsecutiveErrors.
   */
  @java.lang.Override
  public int getEnforcingConsecutiveErrors() {
    return enforcingConsecutiveErrors_;
  }

  public static final int ENFORCING_CONSECUTIVE_GATEWAY_FAILURE_FIELD_NUMBER = 126005210;
  private int enforcingConsecutiveGatewayFailure_;
  /**
   *
   *
   * <pre>
   * The percentage chance that a host will be actually ejected when an outlier status is detected through consecutive gateway failures. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100.
   * </pre>
   *
   * <code>int32 enforcing_consecutive_gateway_failure = 126005210;</code>
   *
   * @return The enforcingConsecutiveGatewayFailure.
   */
  @java.lang.Override
  public int getEnforcingConsecutiveGatewayFailure() {
    return enforcingConsecutiveGatewayFailure_;
  }

  public static final int ENFORCING_SUCCESS_RATE_FIELD_NUMBER = 194508732;
  private int enforcingSuccessRate_;
  /**
   *
   *
   * <pre>
   * The percentage chance that a host will be actually ejected when an outlier status is detected through success rate statistics. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100.
   * </pre>
   *
   * <code>int32 enforcing_success_rate = 194508732;</code>
   *
   * @return The enforcingSuccessRate.
   */
  @java.lang.Override
  public int getEnforcingSuccessRate() {
    return enforcingSuccessRate_;
  }

  public static final int INTERVAL_FIELD_NUMBER = 33547461;
  private com.google.cloud.compute.v1.Duration interval_;
  /**
   *
   *
   * <pre>
   * Time interval between ejection analysis sweeps. This can result in both new ejections as well as hosts being returned to service. Defaults to 1 second.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.Duration interval = 33547461;</code>
   *
   * @return Whether the interval field is set.
   */
  @java.lang.Override
  public boolean hasInterval() {
    return interval_ != null;
  }
  /**
   *
   *
   * <pre>
   * Time interval between ejection analysis sweeps. This can result in both new ejections as well as hosts being returned to service. Defaults to 1 second.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.Duration interval = 33547461;</code>
   *
   * @return The interval.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.Duration getInterval() {
    return interval_ == null
        ? com.google.cloud.compute.v1.Duration.getDefaultInstance()
        : interval_;
  }
  /**
   *
   *
   * <pre>
   * Time interval between ejection analysis sweeps. This can result in both new ejections as well as hosts being returned to service. Defaults to 1 second.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.Duration interval = 33547461;</code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.DurationOrBuilder getIntervalOrBuilder() {
    return getInterval();
  }

  public static final int MAX_EJECTION_PERCENT_FIELD_NUMBER = 18436888;
  private int maxEjectionPercent_;
  /**
   *
   *
   * <pre>
   * Maximum percentage of hosts in the load balancing pool for the backend service that can be ejected. Defaults to 50%.
   * </pre>
   *
   * <code>int32 max_ejection_percent = 18436888;</code>
   *
   * @return The maxEjectionPercent.
   */
  @java.lang.Override
  public int getMaxEjectionPercent() {
    return maxEjectionPercent_;
  }

  public static final int SUCCESS_RATE_MINIMUM_HOSTS_FIELD_NUMBER = 257331447;
  private int successRateMinimumHosts_;
  /**
   *
   *
   * <pre>
   * The number of hosts in a cluster that must have enough request volume to detect success rate outliers. If the number of hosts is less than this setting, outlier detection via success rate statistics is not performed for any host in the cluster. Defaults to 5.
   * </pre>
   *
   * <code>int32 success_rate_minimum_hosts = 257331447;</code>
   *
   * @return The successRateMinimumHosts.
   */
  @java.lang.Override
  public int getSuccessRateMinimumHosts() {
    return successRateMinimumHosts_;
  }

  public static final int SUCCESS_RATE_REQUEST_VOLUME_FIELD_NUMBER = 12989901;
  private int successRateRequestVolume_;
  /**
   *
   *
   * <pre>
   * The minimum number of total requests that must be collected in one interval (as defined by the interval duration above) to include this host in success rate based outlier detection. If the volume is lower than this setting, outlier detection via success rate statistics is not performed for that host. Defaults to 100.
   * </pre>
   *
   * <code>int32 success_rate_request_volume = 12989901;</code>
   *
   * @return The successRateRequestVolume.
   */
  @java.lang.Override
  public int getSuccessRateRequestVolume() {
    return successRateRequestVolume_;
  }

  public static final int SUCCESS_RATE_STDEV_FACTOR_FIELD_NUMBER = 174735773;
  private int successRateStdevFactor_;
  /**
   *
   *
   * <pre>
   * This factor is used to determine the ejection threshold for success rate outlier ejection. The ejection threshold is the difference between the mean success rate, and the product of this factor and the standard deviation of the mean success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided by a thousand to get a double. That is, if the desired factor is 1.9, the runtime value should be 1900. Defaults to 1900.
   * </pre>
   *
   * <code>int32 success_rate_stdev_factor = 174735773;</code>
   *
   * @return The successRateStdevFactor.
   */
  @java.lang.Override
  public int getSuccessRateStdevFactor() {
    return successRateStdevFactor_;
  }

  private byte memoizedIsInitialized = -1;

  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    if (successRateRequestVolume_ != 0) {
      output.writeInt32(12989901, successRateRequestVolume_);
    }
    if (maxEjectionPercent_ != 0) {
      output.writeInt32(18436888, maxEjectionPercent_);
    }
    if (interval_ != null) {
      output.writeMessage(33547461, getInterval());
    }
    if (baseEjectionTime_ != null) {
      output.writeMessage(80997255, getBaseEjectionTime());
    }
    if (consecutiveErrors_ != 0) {
      output.writeInt32(118757792, consecutiveErrors_);
    }
    if (enforcingConsecutiveGatewayFailure_ != 0) {
      output.writeInt32(126005210, enforcingConsecutiveGatewayFailure_);
    }
    if (consecutiveGatewayFailure_ != 0) {
      output.writeInt32(149068794, consecutiveGatewayFailure_);
    }
    if (successRateStdevFactor_ != 0) {
      output.writeInt32(174735773, successRateStdevFactor_);
    }
    if (enforcingSuccessRate_ != 0) {
      output.writeInt32(194508732, enforcingSuccessRate_);
    }
    if (enforcingConsecutiveErrors_ != 0) {
      output.writeInt32(213133760, enforcingConsecutiveErrors_);
    }
    if (successRateMinimumHosts_ != 0) {
      output.writeInt32(257331447, successRateMinimumHosts_);
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (successRateRequestVolume_ != 0) {
      size +=
          com.google.protobuf.CodedOutputStream.computeInt32Size(
              12989901, successRateRequestVolume_);
    }
    if (maxEjectionPercent_ != 0) {
      size += com.google.protobuf.CodedOutputStream.computeInt32Size(18436888, maxEjectionPercent_);
    }
    if (interval_ != null) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(33547461, getInterval());
    }
    if (baseEjectionTime_ != null) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(80997255, getBaseEjectionTime());
    }
    if (consecutiveErrors_ != 0) {
      size += com.google.protobuf.CodedOutputStream.computeInt32Size(118757792, consecutiveErrors_);
    }
    if (enforcingConsecutiveGatewayFailure_ != 0) {
      size +=
          com.google.protobuf.CodedOutputStream.computeInt32Size(
              126005210, enforcingConsecutiveGatewayFailure_);
    }
    if (consecutiveGatewayFailure_ != 0) {
      size +=
          com.google.protobuf.CodedOutputStream.computeInt32Size(
              149068794, consecutiveGatewayFailure_);
    }
    if (successRateStdevFactor_ != 0) {
      size +=
          com.google.protobuf.CodedOutputStream.computeInt32Size(
              174735773, successRateStdevFactor_);
    }
    if (enforcingSuccessRate_ != 0) {
      size +=
          com.google.protobuf.CodedOutputStream.computeInt32Size(194508732, enforcingSuccessRate_);
    }
    if (enforcingConsecutiveErrors_ != 0) {
      size +=
          com.google.protobuf.CodedOutputStream.computeInt32Size(
              213133760, enforcingConsecutiveErrors_);
    }
    if (successRateMinimumHosts_ != 0) {
      size +=
          com.google.protobuf.CodedOutputStream.computeInt32Size(
              257331447, successRateMinimumHosts_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof com.google.cloud.compute.v1.OutlierDetection)) {
      return super.equals(obj);
    }
    com.google.cloud.compute.v1.OutlierDetection other =
        (com.google.cloud.compute.v1.OutlierDetection) obj;

    if (hasBaseEjectionTime() != other.hasBaseEjectionTime()) return false;
    if (hasBaseEjectionTime()) {
      if (!getBaseEjectionTime().equals(other.getBaseEjectionTime())) return false;
    }
    if (getConsecutiveErrors() != other.getConsecutiveErrors()) return false;
    if (getConsecutiveGatewayFailure() != other.getConsecutiveGatewayFailure()) return false;
    if (getEnforcingConsecutiveErrors() != other.getEnforcingConsecutiveErrors()) return false;
    if (getEnforcingConsecutiveGatewayFailure() != other.getEnforcingConsecutiveGatewayFailure())
      return false;
    if (getEnforcingSuccessRate() != other.getEnforcingSuccessRate()) return false;
    if (hasInterval() != other.hasInterval()) return false;
    if (hasInterval()) {
      if (!getInterval().equals(other.getInterval())) return false;
    }
    if (getMaxEjectionPercent() != other.getMaxEjectionPercent()) return false;
    if (getSuccessRateMinimumHosts() != other.getSuccessRateMinimumHosts()) return false;
    if (getSuccessRateRequestVolume() != other.getSuccessRateRequestVolume()) return false;
    if (getSuccessRateStdevFactor() != other.getSuccessRateStdevFactor()) return false;
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (hasBaseEjectionTime()) {
      hash = (37 * hash) + BASE_EJECTION_TIME_FIELD_NUMBER;
      hash = (53 * hash) + getBaseEjectionTime().hashCode();
    }
    hash = (37 * hash) + CONSECUTIVE_ERRORS_FIELD_NUMBER;
    hash = (53 * hash) + getConsecutiveErrors();
    hash = (37 * hash) + CONSECUTIVE_GATEWAY_FAILURE_FIELD_NUMBER;
    hash = (53 * hash) + getConsecutiveGatewayFailure();
    hash = (37 * hash) + ENFORCING_CONSECUTIVE_ERRORS_FIELD_NUMBER;
    hash = (53 * hash) + getEnforcingConsecutiveErrors();
    hash = (37 * hash) + ENFORCING_CONSECUTIVE_GATEWAY_FAILURE_FIELD_NUMBER;
    hash = (53 * hash) + getEnforcingConsecutiveGatewayFailure();
    hash = (37 * hash) + ENFORCING_SUCCESS_RATE_FIELD_NUMBER;
    hash = (53 * hash) + getEnforcingSuccessRate();
    if (hasInterval()) {
      hash = (37 * hash) + INTERVAL_FIELD_NUMBER;
      hash = (53 * hash) + getInterval().hashCode();
    }
    hash = (37 * hash) + MAX_EJECTION_PERCENT_FIELD_NUMBER;
    hash = (53 * hash) + getMaxEjectionPercent();
    hash = (37 * hash) + SUCCESS_RATE_MINIMUM_HOSTS_FIELD_NUMBER;
    hash = (53 * hash) + getSuccessRateMinimumHosts();
    hash = (37 * hash) + SUCCESS_RATE_REQUEST_VOLUME_FIELD_NUMBER;
    hash = (53 * hash) + getSuccessRateRequestVolume();
    hash = (37 * hash) + SUCCESS_RATE_STDEV_FACTOR_FIELD_NUMBER;
    hash = (53 * hash) + getSuccessRateStdevFactor();
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.google.cloud.compute.v1.OutlierDetection parseFrom(java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.OutlierDetection parseFrom(
      java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.OutlierDetection parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.OutlierDetection parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.OutlierDetection parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.OutlierDetection parseFrom(
      byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.OutlierDetection parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.OutlierDetection parseFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.OutlierDetection parseDelimitedFrom(
      java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.OutlierDetection parseDelimitedFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.OutlierDetection parseFrom(
      com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.OutlierDetection parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() {
    return newBuilder();
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }

  public static Builder newBuilder(com.google.cloud.compute.v1.OutlierDetection prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   *
   *
   * <pre>
   * Settings controlling the eviction of unhealthy hosts from the load balancing pool for the backend service.
   * </pre>
   *
   * Protobuf type {@code google.cloud.compute.v1.OutlierDetection}
   */
  public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
      implements
      // @@protoc_insertion_point(builder_implements:google.cloud.compute.v1.OutlierDetection)
      com.google.cloud.compute.v1.OutlierDetectionOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_OutlierDetection_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_OutlierDetection_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.cloud.compute.v1.OutlierDetection.class,
              com.google.cloud.compute.v1.OutlierDetection.Builder.class);
    }

    // Construct using com.google.cloud.compute.v1.OutlierDetection.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }

    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
    }

    @java.lang.Override
    public Builder clear() {
      super.clear();
      if (baseEjectionTimeBuilder_ == null) {
        baseEjectionTime_ = null;
      } else {
        baseEjectionTime_ = null;
        baseEjectionTimeBuilder_ = null;
      }
      consecutiveErrors_ = 0;

      consecutiveGatewayFailure_ = 0;

      enforcingConsecutiveErrors_ = 0;

      enforcingConsecutiveGatewayFailure_ = 0;

      enforcingSuccessRate_ = 0;

      if (intervalBuilder_ == null) {
        interval_ = null;
      } else {
        interval_ = null;
        intervalBuilder_ = null;
      }
      maxEjectionPercent_ = 0;

      successRateMinimumHosts_ = 0;

      successRateRequestVolume_ = 0;

      successRateStdevFactor_ = 0;

      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_OutlierDetection_descriptor;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.OutlierDetection getDefaultInstanceForType() {
      return com.google.cloud.compute.v1.OutlierDetection.getDefaultInstance();
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.OutlierDetection build() {
      com.google.cloud.compute.v1.OutlierDetection result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.OutlierDetection buildPartial() {
      com.google.cloud.compute.v1.OutlierDetection result =
          new com.google.cloud.compute.v1.OutlierDetection(this);
      if (baseEjectionTimeBuilder_ == null) {
        result.baseEjectionTime_ = baseEjectionTime_;
      } else {
        result.baseEjectionTime_ = baseEjectionTimeBuilder_.build();
      }
      result.consecutiveErrors_ = consecutiveErrors_;
      result.consecutiveGatewayFailure_ = consecutiveGatewayFailure_;
      result.enforcingConsecutiveErrors_ = enforcingConsecutiveErrors_;
      result.enforcingConsecutiveGatewayFailure_ = enforcingConsecutiveGatewayFailure_;
      result.enforcingSuccessRate_ = enforcingSuccessRate_;
      if (intervalBuilder_ == null) {
        result.interval_ = interval_;
      } else {
        result.interval_ = intervalBuilder_.build();
      }
      result.maxEjectionPercent_ = maxEjectionPercent_;
      result.successRateMinimumHosts_ = successRateMinimumHosts_;
      result.successRateRequestVolume_ = successRateRequestVolume_;
      result.successRateStdevFactor_ = successRateStdevFactor_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }

    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.setField(field, value);
    }

    @java.lang.Override
    public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }

    @java.lang.Override
    public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }

    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }

    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }

    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.google.cloud.compute.v1.OutlierDetection) {
        return mergeFrom((com.google.cloud.compute.v1.OutlierDetection) other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.google.cloud.compute.v1.OutlierDetection other) {
      if (other == com.google.cloud.compute.v1.OutlierDetection.getDefaultInstance()) return this;
      if (other.hasBaseEjectionTime()) {
        mergeBaseEjectionTime(other.getBaseEjectionTime());
      }
      if (other.getConsecutiveErrors() != 0) {
        setConsecutiveErrors(other.getConsecutiveErrors());
      }
      if (other.getConsecutiveGatewayFailure() != 0) {
        setConsecutiveGatewayFailure(other.getConsecutiveGatewayFailure());
      }
      if (other.getEnforcingConsecutiveErrors() != 0) {
        setEnforcingConsecutiveErrors(other.getEnforcingConsecutiveErrors());
      }
      if (other.getEnforcingConsecutiveGatewayFailure() != 0) {
        setEnforcingConsecutiveGatewayFailure(other.getEnforcingConsecutiveGatewayFailure());
      }
      if (other.getEnforcingSuccessRate() != 0) {
        setEnforcingSuccessRate(other.getEnforcingSuccessRate());
      }
      if (other.hasInterval()) {
        mergeInterval(other.getInterval());
      }
      if (other.getMaxEjectionPercent() != 0) {
        setMaxEjectionPercent(other.getMaxEjectionPercent());
      }
      if (other.getSuccessRateMinimumHosts() != 0) {
        setSuccessRateMinimumHosts(other.getSuccessRateMinimumHosts());
      }
      if (other.getSuccessRateRequestVolume() != 0) {
        setSuccessRateRequestVolume(other.getSuccessRateRequestVolume());
      }
      if (other.getSuccessRateStdevFactor() != 0) {
        setSuccessRateStdevFactor(other.getSuccessRateStdevFactor());
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      com.google.cloud.compute.v1.OutlierDetection parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (com.google.cloud.compute.v1.OutlierDetection) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }

    private com.google.cloud.compute.v1.Duration baseEjectionTime_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.Duration,
            com.google.cloud.compute.v1.Duration.Builder,
            com.google.cloud.compute.v1.DurationOrBuilder>
        baseEjectionTimeBuilder_;
    /**
     *
     *
     * <pre>
     * The base time that a host is ejected for. The real ejection time is equal to the base ejection time multiplied by the number of times the host has been ejected. Defaults to 30000ms or 30s.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration base_ejection_time = 80997255;</code>
     *
     * @return Whether the baseEjectionTime field is set.
     */
    public boolean hasBaseEjectionTime() {
      return baseEjectionTimeBuilder_ != null || baseEjectionTime_ != null;
    }
    /**
     *
     *
     * <pre>
     * The base time that a host is ejected for. The real ejection time is equal to the base ejection time multiplied by the number of times the host has been ejected. Defaults to 30000ms or 30s.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration base_ejection_time = 80997255;</code>
     *
     * @return The baseEjectionTime.
     */
    public com.google.cloud.compute.v1.Duration getBaseEjectionTime() {
      if (baseEjectionTimeBuilder_ == null) {
        return baseEjectionTime_ == null
            ? com.google.cloud.compute.v1.Duration.getDefaultInstance()
            : baseEjectionTime_;
      } else {
        return baseEjectionTimeBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * The base time that a host is ejected for. The real ejection time is equal to the base ejection time multiplied by the number of times the host has been ejected. Defaults to 30000ms or 30s.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration base_ejection_time = 80997255;</code>
     */
    public Builder setBaseEjectionTime(com.google.cloud.compute.v1.Duration value) {
      if (baseEjectionTimeBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        baseEjectionTime_ = value;
        onChanged();
      } else {
        baseEjectionTimeBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     *
     *
     * <pre>
     * The base time that a host is ejected for. The real ejection time is equal to the base ejection time multiplied by the number of times the host has been ejected. Defaults to 30000ms or 30s.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration base_ejection_time = 80997255;</code>
     */
    public Builder setBaseEjectionTime(
        com.google.cloud.compute.v1.Duration.Builder builderForValue) {
      if (baseEjectionTimeBuilder_ == null) {
        baseEjectionTime_ = builderForValue.build();
        onChanged();
      } else {
        baseEjectionTimeBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     *
     *
     * <pre>
     * The base time that a host is ejected for. The real ejection time is equal to the base ejection time multiplied by the number of times the host has been ejected. Defaults to 30000ms or 30s.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration base_ejection_time = 80997255;</code>
     */
    public Builder mergeBaseEjectionTime(com.google.cloud.compute.v1.Duration value) {
      if (baseEjectionTimeBuilder_ == null) {
        if (baseEjectionTime_ != null) {
          baseEjectionTime_ =
              com.google.cloud.compute.v1.Duration.newBuilder(baseEjectionTime_)
                  .mergeFrom(value)
                  .buildPartial();
        } else {
          baseEjectionTime_ = value;
        }
        onChanged();
      } else {
        baseEjectionTimeBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     *
     *
     * <pre>
     * The base time that a host is ejected for. The real ejection time is equal to the base ejection time multiplied by the number of times the host has been ejected. Defaults to 30000ms or 30s.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration base_ejection_time = 80997255;</code>
     */
    public Builder clearBaseEjectionTime() {
      if (baseEjectionTimeBuilder_ == null) {
        baseEjectionTime_ = null;
        onChanged();
      } else {
        baseEjectionTime_ = null;
        baseEjectionTimeBuilder_ = null;
      }

      return this;
    }
    /**
     *
     *
     * <pre>
     * The base time that a host is ejected for. The real ejection time is equal to the base ejection time multiplied by the number of times the host has been ejected. Defaults to 30000ms or 30s.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration base_ejection_time = 80997255;</code>
     */
    public com.google.cloud.compute.v1.Duration.Builder getBaseEjectionTimeBuilder() {

      onChanged();
      return getBaseEjectionTimeFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * The base time that a host is ejected for. The real ejection time is equal to the base ejection time multiplied by the number of times the host has been ejected. Defaults to 30000ms or 30s.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration base_ejection_time = 80997255;</code>
     */
    public com.google.cloud.compute.v1.DurationOrBuilder getBaseEjectionTimeOrBuilder() {
      if (baseEjectionTimeBuilder_ != null) {
        return baseEjectionTimeBuilder_.getMessageOrBuilder();
      } else {
        return baseEjectionTime_ == null
            ? com.google.cloud.compute.v1.Duration.getDefaultInstance()
            : baseEjectionTime_;
      }
    }
    /**
     *
     *
     * <pre>
     * The base time that a host is ejected for. The real ejection time is equal to the base ejection time multiplied by the number of times the host has been ejected. Defaults to 30000ms or 30s.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration base_ejection_time = 80997255;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.Duration,
            com.google.cloud.compute.v1.Duration.Builder,
            com.google.cloud.compute.v1.DurationOrBuilder>
        getBaseEjectionTimeFieldBuilder() {
      if (baseEjectionTimeBuilder_ == null) {
        baseEjectionTimeBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.cloud.compute.v1.Duration,
                com.google.cloud.compute.v1.Duration.Builder,
                com.google.cloud.compute.v1.DurationOrBuilder>(
                getBaseEjectionTime(), getParentForChildren(), isClean());
        baseEjectionTime_ = null;
      }
      return baseEjectionTimeBuilder_;
    }

    private int consecutiveErrors_;
    /**
     *
     *
     * <pre>
     * Number of errors before a host is ejected from the connection pool. When the backend host is accessed over HTTP, a 5xx return code qualifies as an error. Defaults to 5.
     * </pre>
     *
     * <code>int32 consecutive_errors = 118757792;</code>
     *
     * @return The consecutiveErrors.
     */
    @java.lang.Override
    public int getConsecutiveErrors() {
      return consecutiveErrors_;
    }
    /**
     *
     *
     * <pre>
     * Number of errors before a host is ejected from the connection pool. When the backend host is accessed over HTTP, a 5xx return code qualifies as an error. Defaults to 5.
     * </pre>
     *
     * <code>int32 consecutive_errors = 118757792;</code>
     *
     * @param value The consecutiveErrors to set.
     * @return This builder for chaining.
     */
    public Builder setConsecutiveErrors(int value) {

      consecutiveErrors_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Number of errors before a host is ejected from the connection pool. When the backend host is accessed over HTTP, a 5xx return code qualifies as an error. Defaults to 5.
     * </pre>
     *
     * <code>int32 consecutive_errors = 118757792;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearConsecutiveErrors() {

      consecutiveErrors_ = 0;
      onChanged();
      return this;
    }

    private int consecutiveGatewayFailure_;
    /**
     *
     *
     * <pre>
     * The number of consecutive gateway failures (502, 503, 504 status or connection errors that are mapped to one of those status codes) before a consecutive gateway failure ejection occurs. Defaults to 3.
     * </pre>
     *
     * <code>int32 consecutive_gateway_failure = 149068794;</code>
     *
     * @return The consecutiveGatewayFailure.
     */
    @java.lang.Override
    public int getConsecutiveGatewayFailure() {
      return consecutiveGatewayFailure_;
    }
    /**
     *
     *
     * <pre>
     * The number of consecutive gateway failures (502, 503, 504 status or connection errors that are mapped to one of those status codes) before a consecutive gateway failure ejection occurs. Defaults to 3.
     * </pre>
     *
     * <code>int32 consecutive_gateway_failure = 149068794;</code>
     *
     * @param value The consecutiveGatewayFailure to set.
     * @return This builder for chaining.
     */
    public Builder setConsecutiveGatewayFailure(int value) {

      consecutiveGatewayFailure_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The number of consecutive gateway failures (502, 503, 504 status or connection errors that are mapped to one of those status codes) before a consecutive gateway failure ejection occurs. Defaults to 3.
     * </pre>
     *
     * <code>int32 consecutive_gateway_failure = 149068794;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearConsecutiveGatewayFailure() {

      consecutiveGatewayFailure_ = 0;
      onChanged();
      return this;
    }

    private int enforcingConsecutiveErrors_;
    /**
     *
     *
     * <pre>
     * The percentage chance that a host will be actually ejected when an outlier status is detected through consecutive 5xx. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 0.
     * </pre>
     *
     * <code>int32 enforcing_consecutive_errors = 213133760;</code>
     *
     * @return The enforcingConsecutiveErrors.
     */
    @java.lang.Override
    public int getEnforcingConsecutiveErrors() {
      return enforcingConsecutiveErrors_;
    }
    /**
     *
     *
     * <pre>
     * The percentage chance that a host will be actually ejected when an outlier status is detected through consecutive 5xx. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 0.
     * </pre>
     *
     * <code>int32 enforcing_consecutive_errors = 213133760;</code>
     *
     * @param value The enforcingConsecutiveErrors to set.
     * @return This builder for chaining.
     */
    public Builder setEnforcingConsecutiveErrors(int value) {

      enforcingConsecutiveErrors_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The percentage chance that a host will be actually ejected when an outlier status is detected through consecutive 5xx. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 0.
     * </pre>
     *
     * <code>int32 enforcing_consecutive_errors = 213133760;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearEnforcingConsecutiveErrors() {

      enforcingConsecutiveErrors_ = 0;
      onChanged();
      return this;
    }

    private int enforcingConsecutiveGatewayFailure_;
    /**
     *
     *
     * <pre>
     * The percentage chance that a host will be actually ejected when an outlier status is detected through consecutive gateway failures. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100.
     * </pre>
     *
     * <code>int32 enforcing_consecutive_gateway_failure = 126005210;</code>
     *
     * @return The enforcingConsecutiveGatewayFailure.
     */
    @java.lang.Override
    public int getEnforcingConsecutiveGatewayFailure() {
      return enforcingConsecutiveGatewayFailure_;
    }
    /**
     *
     *
     * <pre>
     * The percentage chance that a host will be actually ejected when an outlier status is detected through consecutive gateway failures. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100.
     * </pre>
     *
     * <code>int32 enforcing_consecutive_gateway_failure = 126005210;</code>
     *
     * @param value The enforcingConsecutiveGatewayFailure to set.
     * @return This builder for chaining.
     */
    public Builder setEnforcingConsecutiveGatewayFailure(int value) {

      enforcingConsecutiveGatewayFailure_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The percentage chance that a host will be actually ejected when an outlier status is detected through consecutive gateway failures. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100.
     * </pre>
     *
     * <code>int32 enforcing_consecutive_gateway_failure = 126005210;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearEnforcingConsecutiveGatewayFailure() {

      enforcingConsecutiveGatewayFailure_ = 0;
      onChanged();
      return this;
    }

    private int enforcingSuccessRate_;
    /**
     *
     *
     * <pre>
     * The percentage chance that a host will be actually ejected when an outlier status is detected through success rate statistics. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100.
     * </pre>
     *
     * <code>int32 enforcing_success_rate = 194508732;</code>
     *
     * @return The enforcingSuccessRate.
     */
    @java.lang.Override
    public int getEnforcingSuccessRate() {
      return enforcingSuccessRate_;
    }
    /**
     *
     *
     * <pre>
     * The percentage chance that a host will be actually ejected when an outlier status is detected through success rate statistics. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100.
     * </pre>
     *
     * <code>int32 enforcing_success_rate = 194508732;</code>
     *
     * @param value The enforcingSuccessRate to set.
     * @return This builder for chaining.
     */
    public Builder setEnforcingSuccessRate(int value) {

      enforcingSuccessRate_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The percentage chance that a host will be actually ejected when an outlier status is detected through success rate statistics. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100.
     * </pre>
     *
     * <code>int32 enforcing_success_rate = 194508732;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearEnforcingSuccessRate() {

      enforcingSuccessRate_ = 0;
      onChanged();
      return this;
    }

    private com.google.cloud.compute.v1.Duration interval_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.Duration,
            com.google.cloud.compute.v1.Duration.Builder,
            com.google.cloud.compute.v1.DurationOrBuilder>
        intervalBuilder_;
    /**
     *
     *
     * <pre>
     * Time interval between ejection analysis sweeps. This can result in both new ejections as well as hosts being returned to service. Defaults to 1 second.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration interval = 33547461;</code>
     *
     * @return Whether the interval field is set.
     */
    public boolean hasInterval() {
      return intervalBuilder_ != null || interval_ != null;
    }
    /**
     *
     *
     * <pre>
     * Time interval between ejection analysis sweeps. This can result in both new ejections as well as hosts being returned to service. Defaults to 1 second.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration interval = 33547461;</code>
     *
     * @return The interval.
     */
    public com.google.cloud.compute.v1.Duration getInterval() {
      if (intervalBuilder_ == null) {
        return interval_ == null
            ? com.google.cloud.compute.v1.Duration.getDefaultInstance()
            : interval_;
      } else {
        return intervalBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * Time interval between ejection analysis sweeps. This can result in both new ejections as well as hosts being returned to service. Defaults to 1 second.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration interval = 33547461;</code>
     */
    public Builder setInterval(com.google.cloud.compute.v1.Duration value) {
      if (intervalBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        interval_ = value;
        onChanged();
      } else {
        intervalBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     *
     *
     * <pre>
     * Time interval between ejection analysis sweeps. This can result in both new ejections as well as hosts being returned to service. Defaults to 1 second.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration interval = 33547461;</code>
     */
    public Builder setInterval(com.google.cloud.compute.v1.Duration.Builder builderForValue) {
      if (intervalBuilder_ == null) {
        interval_ = builderForValue.build();
        onChanged();
      } else {
        intervalBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     *
     *
     * <pre>
     * Time interval between ejection analysis sweeps. This can result in both new ejections as well as hosts being returned to service. Defaults to 1 second.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration interval = 33547461;</code>
     */
    public Builder mergeInterval(com.google.cloud.compute.v1.Duration value) {
      if (intervalBuilder_ == null) {
        if (interval_ != null) {
          interval_ =
              com.google.cloud.compute.v1.Duration.newBuilder(interval_)
                  .mergeFrom(value)
                  .buildPartial();
        } else {
          interval_ = value;
        }
        onChanged();
      } else {
        intervalBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     *
     *
     * <pre>
     * Time interval between ejection analysis sweeps. This can result in both new ejections as well as hosts being returned to service. Defaults to 1 second.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration interval = 33547461;</code>
     */
    public Builder clearInterval() {
      if (intervalBuilder_ == null) {
        interval_ = null;
        onChanged();
      } else {
        interval_ = null;
        intervalBuilder_ = null;
      }

      return this;
    }
    /**
     *
     *
     * <pre>
     * Time interval between ejection analysis sweeps. This can result in both new ejections as well as hosts being returned to service. Defaults to 1 second.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration interval = 33547461;</code>
     */
    public com.google.cloud.compute.v1.Duration.Builder getIntervalBuilder() {

      onChanged();
      return getIntervalFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * Time interval between ejection analysis sweeps. This can result in both new ejections as well as hosts being returned to service. Defaults to 1 second.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration interval = 33547461;</code>
     */
    public com.google.cloud.compute.v1.DurationOrBuilder getIntervalOrBuilder() {
      if (intervalBuilder_ != null) {
        return intervalBuilder_.getMessageOrBuilder();
      } else {
        return interval_ == null
            ? com.google.cloud.compute.v1.Duration.getDefaultInstance()
            : interval_;
      }
    }
    /**
     *
     *
     * <pre>
     * Time interval between ejection analysis sweeps. This can result in both new ejections as well as hosts being returned to service. Defaults to 1 second.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.Duration interval = 33547461;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.Duration,
            com.google.cloud.compute.v1.Duration.Builder,
            com.google.cloud.compute.v1.DurationOrBuilder>
        getIntervalFieldBuilder() {
      if (intervalBuilder_ == null) {
        intervalBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.cloud.compute.v1.Duration,
                com.google.cloud.compute.v1.Duration.Builder,
                com.google.cloud.compute.v1.DurationOrBuilder>(
                getInterval(), getParentForChildren(), isClean());
        interval_ = null;
      }
      return intervalBuilder_;
    }

    private int maxEjectionPercent_;
    /**
     *
     *
     * <pre>
     * Maximum percentage of hosts in the load balancing pool for the backend service that can be ejected. Defaults to 50%.
     * </pre>
     *
     * <code>int32 max_ejection_percent = 18436888;</code>
     *
     * @return The maxEjectionPercent.
     */
    @java.lang.Override
    public int getMaxEjectionPercent() {
      return maxEjectionPercent_;
    }
    /**
     *
     *
     * <pre>
     * Maximum percentage of hosts in the load balancing pool for the backend service that can be ejected. Defaults to 50%.
     * </pre>
     *
     * <code>int32 max_ejection_percent = 18436888;</code>
     *
     * @param value The maxEjectionPercent to set.
     * @return This builder for chaining.
     */
    public Builder setMaxEjectionPercent(int value) {

      maxEjectionPercent_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Maximum percentage of hosts in the load balancing pool for the backend service that can be ejected. Defaults to 50%.
     * </pre>
     *
     * <code>int32 max_ejection_percent = 18436888;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearMaxEjectionPercent() {

      maxEjectionPercent_ = 0;
      onChanged();
      return this;
    }

    private int successRateMinimumHosts_;
    /**
     *
     *
     * <pre>
     * The number of hosts in a cluster that must have enough request volume to detect success rate outliers. If the number of hosts is less than this setting, outlier detection via success rate statistics is not performed for any host in the cluster. Defaults to 5.
     * </pre>
     *
     * <code>int32 success_rate_minimum_hosts = 257331447;</code>
     *
     * @return The successRateMinimumHosts.
     */
    @java.lang.Override
    public int getSuccessRateMinimumHosts() {
      return successRateMinimumHosts_;
    }
    /**
     *
     *
     * <pre>
     * The number of hosts in a cluster that must have enough request volume to detect success rate outliers. If the number of hosts is less than this setting, outlier detection via success rate statistics is not performed for any host in the cluster. Defaults to 5.
     * </pre>
     *
     * <code>int32 success_rate_minimum_hosts = 257331447;</code>
     *
     * @param value The successRateMinimumHosts to set.
     * @return This builder for chaining.
     */
    public Builder setSuccessRateMinimumHosts(int value) {

      successRateMinimumHosts_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The number of hosts in a cluster that must have enough request volume to detect success rate outliers. If the number of hosts is less than this setting, outlier detection via success rate statistics is not performed for any host in the cluster. Defaults to 5.
     * </pre>
     *
     * <code>int32 success_rate_minimum_hosts = 257331447;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearSuccessRateMinimumHosts() {

      successRateMinimumHosts_ = 0;
      onChanged();
      return this;
    }

    private int successRateRequestVolume_;
    /**
     *
     *
     * <pre>
     * The minimum number of total requests that must be collected in one interval (as defined by the interval duration above) to include this host in success rate based outlier detection. If the volume is lower than this setting, outlier detection via success rate statistics is not performed for that host. Defaults to 100.
     * </pre>
     *
     * <code>int32 success_rate_request_volume = 12989901;</code>
     *
     * @return The successRateRequestVolume.
     */
    @java.lang.Override
    public int getSuccessRateRequestVolume() {
      return successRateRequestVolume_;
    }
    /**
     *
     *
     * <pre>
     * The minimum number of total requests that must be collected in one interval (as defined by the interval duration above) to include this host in success rate based outlier detection. If the volume is lower than this setting, outlier detection via success rate statistics is not performed for that host. Defaults to 100.
     * </pre>
     *
     * <code>int32 success_rate_request_volume = 12989901;</code>
     *
     * @param value The successRateRequestVolume to set.
     * @return This builder for chaining.
     */
    public Builder setSuccessRateRequestVolume(int value) {

      successRateRequestVolume_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The minimum number of total requests that must be collected in one interval (as defined by the interval duration above) to include this host in success rate based outlier detection. If the volume is lower than this setting, outlier detection via success rate statistics is not performed for that host. Defaults to 100.
     * </pre>
     *
     * <code>int32 success_rate_request_volume = 12989901;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearSuccessRateRequestVolume() {

      successRateRequestVolume_ = 0;
      onChanged();
      return this;
    }

    private int successRateStdevFactor_;
    /**
     *
     *
     * <pre>
     * This factor is used to determine the ejection threshold for success rate outlier ejection. The ejection threshold is the difference between the mean success rate, and the product of this factor and the standard deviation of the mean success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided by a thousand to get a double. That is, if the desired factor is 1.9, the runtime value should be 1900. Defaults to 1900.
     * </pre>
     *
     * <code>int32 success_rate_stdev_factor = 174735773;</code>
     *
     * @return The successRateStdevFactor.
     */
    @java.lang.Override
    public int getSuccessRateStdevFactor() {
      return successRateStdevFactor_;
    }
    /**
     *
     *
     * <pre>
     * This factor is used to determine the ejection threshold for success rate outlier ejection. The ejection threshold is the difference between the mean success rate, and the product of this factor and the standard deviation of the mean success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided by a thousand to get a double. That is, if the desired factor is 1.9, the runtime value should be 1900. Defaults to 1900.
     * </pre>
     *
     * <code>int32 success_rate_stdev_factor = 174735773;</code>
     *
     * @param value The successRateStdevFactor to set.
     * @return This builder for chaining.
     */
    public Builder setSuccessRateStdevFactor(int value) {

      successRateStdevFactor_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * This factor is used to determine the ejection threshold for success rate outlier ejection. The ejection threshold is the difference between the mean success rate, and the product of this factor and the standard deviation of the mean success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided by a thousand to get a double. That is, if the desired factor is 1.9, the runtime value should be 1900. Defaults to 1900.
     * </pre>
     *
     * <code>int32 success_rate_stdev_factor = 174735773;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearSuccessRateStdevFactor() {

      successRateStdevFactor_ = 0;
      onChanged();
      return this;
    }

    @java.lang.Override
    public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }

    // @@protoc_insertion_point(builder_scope:google.cloud.compute.v1.OutlierDetection)
  }

  // @@protoc_insertion_point(class_scope:google.cloud.compute.v1.OutlierDetection)
  private static final com.google.cloud.compute.v1.OutlierDetection DEFAULT_INSTANCE;

  static {
    DEFAULT_INSTANCE = new com.google.cloud.compute.v1.OutlierDetection();
  }

  public static com.google.cloud.compute.v1.OutlierDetection getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<OutlierDetection> PARSER =
      new com.google.protobuf.AbstractParser<OutlierDetection>() {
        @java.lang.Override
        public OutlierDetection parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new OutlierDetection(input, extensionRegistry);
        }
      };

  public static com.google.protobuf.Parser<OutlierDetection> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<OutlierDetection> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.cloud.compute.v1.OutlierDetection getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }
}
