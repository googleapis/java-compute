/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/compute/v1/compute.proto

package com.google.cloud.compute.v1;

/**
 *
 *
 * <pre>
 * </pre>
 *
 * Protobuf type {@code google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy}
 */
public final class InstanceGroupManagerUpdatePolicy extends com.google.protobuf.GeneratedMessageV3
    implements
    // @@protoc_insertion_point(message_implements:google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy)
    InstanceGroupManagerUpdatePolicyOrBuilder {
  private static final long serialVersionUID = 0L;
  // Use InstanceGroupManagerUpdatePolicy.newBuilder() to construct.
  private InstanceGroupManagerUpdatePolicy(
      com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }

  private InstanceGroupManagerUpdatePolicy() {
    instanceRedistributionType_ = "";
    minimalAction_ = "";
    replacementMethod_ = "";
    type_ = "";
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(UnusedPrivateParameter unused) {
    return new InstanceGroupManagerUpdatePolicy();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
    return this.unknownFields;
  }

  private InstanceGroupManagerUpdatePolicy(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 17052834:
            {
              java.lang.String s = input.readStringRequireUtf8();

              minimalAction_ = s;
              break;
            }
          case 28604882:
            {
              java.lang.String s = input.readStringRequireUtf8();

              type_ = s;
              break;
            }
          case 193559746:
            {
              java.lang.String s = input.readStringRequireUtf8();

              instanceRedistributionType_ = s;
              break;
            }
          case 273097882:
            {
              com.google.cloud.compute.v1.FixedOrPercent.Builder subBuilder = null;
              if (maxSurge_ != null) {
                subBuilder = maxSurge_.toBuilder();
              }
              maxSurge_ =
                  input.readMessage(
                      com.google.cloud.compute.v1.FixedOrPercent.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(maxSurge_);
                maxSurge_ = subBuilder.buildPartial();
              }

              break;
            }
          case 1092038570:
            {
              com.google.cloud.compute.v1.FixedOrPercent.Builder subBuilder = null;
              if (maxUnavailable_ != null) {
                subBuilder = maxUnavailable_.toBuilder();
              }
              maxUnavailable_ =
                  input.readMessage(
                      com.google.cloud.compute.v1.FixedOrPercent.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(maxUnavailable_);
                maxUnavailable_ = subBuilder.buildPartial();
              }

              break;
            }
          case 1899969906:
            {
              java.lang.String s = input.readStringRequireUtf8();

              replacementMethod_ = s;
              break;
            }
          default:
            {
              if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(e).setUnfinishedMessage(this);
    } finally {
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }

  public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_InstanceGroupManagerUpdatePolicy_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.google.cloud.compute.v1.Compute
        .internal_static_google_cloud_compute_v1_InstanceGroupManagerUpdatePolicy_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.class,
            com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.Builder.class);
  }

  public static final int INSTANCE_REDISTRIBUTION_TYPE_FIELD_NUMBER = 24194968;
  private volatile java.lang.Object instanceRedistributionType_;
  /**
   *
   *
   * <pre>
   * The  instance redistribution policy for regional managed instance groups. Valid values are:
   * - PROACTIVE (default): The group attempts to maintain an even distribution of VM instances across zones in the region.
   * - NONE: For non-autoscaled groups, proactive redistribution is disabled.
   * </pre>
   *
   * <code>string instance_redistribution_type = 24194968;</code>
   *
   * @return The instanceRedistributionType.
   */
  @java.lang.Override
  public java.lang.String getInstanceRedistributionType() {
    java.lang.Object ref = instanceRedistributionType_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      instanceRedistributionType_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * The  instance redistribution policy for regional managed instance groups. Valid values are:
   * - PROACTIVE (default): The group attempts to maintain an even distribution of VM instances across zones in the region.
   * - NONE: For non-autoscaled groups, proactive redistribution is disabled.
   * </pre>
   *
   * <code>string instance_redistribution_type = 24194968;</code>
   *
   * @return The bytes for instanceRedistributionType.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getInstanceRedistributionTypeBytes() {
    java.lang.Object ref = instanceRedistributionType_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      instanceRedistributionType_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int MAX_SURGE_FIELD_NUMBER = 34137235;
  private com.google.cloud.compute.v1.FixedOrPercent maxSurge_;
  /**
   *
   *
   * <pre>
   * The maximum number of instances that can be created above the specified targetSize during the update process. By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
   * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxSurge.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.FixedOrPercent max_surge = 34137235;</code>
   *
   * @return Whether the maxSurge field is set.
   */
  @java.lang.Override
  public boolean hasMaxSurge() {
    return maxSurge_ != null;
  }
  /**
   *
   *
   * <pre>
   * The maximum number of instances that can be created above the specified targetSize during the update process. By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
   * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxSurge.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.FixedOrPercent max_surge = 34137235;</code>
   *
   * @return The maxSurge.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.FixedOrPercent getMaxSurge() {
    return maxSurge_ == null
        ? com.google.cloud.compute.v1.FixedOrPercent.getDefaultInstance()
        : maxSurge_;
  }
  /**
   *
   *
   * <pre>
   * The maximum number of instances that can be created above the specified targetSize during the update process. By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
   * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxSurge.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.FixedOrPercent max_surge = 34137235;</code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.FixedOrPercentOrBuilder getMaxSurgeOrBuilder() {
    return getMaxSurge();
  }

  public static final int MAX_UNAVAILABLE_FIELD_NUMBER = 136504821;
  private com.google.cloud.compute.v1.FixedOrPercent maxUnavailable_;
  /**
   *
   *
   * <pre>
   * The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied:
   * - The instance's status is RUNNING.
   * - If there is a health check on the instance group, the instance's liveness health check result must be HEALTHY at least once. If there is no health check on the group, then the instance only needs to have a status of RUNNING to be considered available.  By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
   * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxUnavailable.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.FixedOrPercent max_unavailable = 136504821;</code>
   *
   * @return Whether the maxUnavailable field is set.
   */
  @java.lang.Override
  public boolean hasMaxUnavailable() {
    return maxUnavailable_ != null;
  }
  /**
   *
   *
   * <pre>
   * The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied:
   * - The instance's status is RUNNING.
   * - If there is a health check on the instance group, the instance's liveness health check result must be HEALTHY at least once. If there is no health check on the group, then the instance only needs to have a status of RUNNING to be considered available.  By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
   * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxUnavailable.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.FixedOrPercent max_unavailable = 136504821;</code>
   *
   * @return The maxUnavailable.
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.FixedOrPercent getMaxUnavailable() {
    return maxUnavailable_ == null
        ? com.google.cloud.compute.v1.FixedOrPercent.getDefaultInstance()
        : maxUnavailable_;
  }
  /**
   *
   *
   * <pre>
   * The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied:
   * - The instance's status is RUNNING.
   * - If there is a health check on the instance group, the instance's liveness health check result must be HEALTHY at least once. If there is no health check on the group, then the instance only needs to have a status of RUNNING to be considered available.  By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
   * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxUnavailable.
   * </pre>
   *
   * <code>.google.cloud.compute.v1.FixedOrPercent max_unavailable = 136504821;</code>
   */
  @java.lang.Override
  public com.google.cloud.compute.v1.FixedOrPercentOrBuilder getMaxUnavailableOrBuilder() {
    return getMaxUnavailable();
  }

  public static final int MINIMAL_ACTION_FIELD_NUMBER = 2131604;
  private volatile java.lang.Object minimalAction_;
  /**
   *
   *
   * <pre>
   * Minimal action to be taken on an instance. You can specify either RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a RESTART, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
   * </pre>
   *
   * <code>string minimal_action = 2131604;</code>
   *
   * @return The minimalAction.
   */
  @java.lang.Override
  public java.lang.String getMinimalAction() {
    java.lang.Object ref = minimalAction_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      minimalAction_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * Minimal action to be taken on an instance. You can specify either RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a RESTART, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
   * </pre>
   *
   * <code>string minimal_action = 2131604;</code>
   *
   * @return The bytes for minimalAction.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getMinimalActionBytes() {
    java.lang.Object ref = minimalAction_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      minimalAction_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int REPLACEMENT_METHOD_FIELD_NUMBER = 237496238;
  private volatile java.lang.Object replacementMethod_;
  /**
   *
   *
   * <pre>
   * What action should be used to replace instances. See minimal_action.REPLACE
   * </pre>
   *
   * <code>string replacement_method = 237496238;</code>
   *
   * @return The replacementMethod.
   */
  @java.lang.Override
  public java.lang.String getReplacementMethod() {
    java.lang.Object ref = replacementMethod_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      replacementMethod_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * What action should be used to replace instances. See minimal_action.REPLACE
   * </pre>
   *
   * <code>string replacement_method = 237496238;</code>
   *
   * @return The bytes for replacementMethod.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getReplacementMethodBytes() {
    java.lang.Object ref = replacementMethod_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      replacementMethod_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  public static final int TYPE_FIELD_NUMBER = 3575610;
  private volatile java.lang.Object type_;
  /**
   *
   *
   * <pre>
   * The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
   * </pre>
   *
   * <code>string type = 3575610;</code>
   *
   * @return The type.
   */
  @java.lang.Override
  public java.lang.String getType() {
    java.lang.Object ref = type_;
    if (ref instanceof java.lang.String) {
      return (java.lang.String) ref;
    } else {
      com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
      java.lang.String s = bs.toStringUtf8();
      type_ = s;
      return s;
    }
  }
  /**
   *
   *
   * <pre>
   * The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
   * </pre>
   *
   * <code>string type = 3575610;</code>
   *
   * @return The bytes for type.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getTypeBytes() {
    java.lang.Object ref = type_;
    if (ref instanceof java.lang.String) {
      com.google.protobuf.ByteString b =
          com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
      type_ = b;
      return b;
    } else {
      return (com.google.protobuf.ByteString) ref;
    }
  }

  private byte memoizedIsInitialized = -1;

  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    if (!getMinimalActionBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 2131604, minimalAction_);
    }
    if (!getTypeBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 3575610, type_);
    }
    if (!getInstanceRedistributionTypeBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(
          output, 24194968, instanceRedistributionType_);
    }
    if (maxSurge_ != null) {
      output.writeMessage(34137235, getMaxSurge());
    }
    if (maxUnavailable_ != null) {
      output.writeMessage(136504821, getMaxUnavailable());
    }
    if (!getReplacementMethodBytes().isEmpty()) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 237496238, replacementMethod_);
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (!getMinimalActionBytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2131604, minimalAction_);
    }
    if (!getTypeBytes().isEmpty()) {
      size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3575610, type_);
    }
    if (!getInstanceRedistributionTypeBytes().isEmpty()) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(
              24194968, instanceRedistributionType_);
    }
    if (maxSurge_ != null) {
      size += com.google.protobuf.CodedOutputStream.computeMessageSize(34137235, getMaxSurge());
    }
    if (maxUnavailable_ != null) {
      size +=
          com.google.protobuf.CodedOutputStream.computeMessageSize(136504821, getMaxUnavailable());
    }
    if (!getReplacementMethodBytes().isEmpty()) {
      size +=
          com.google.protobuf.GeneratedMessageV3.computeStringSize(237496238, replacementMethod_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy)) {
      return super.equals(obj);
    }
    com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy other =
        (com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy) obj;

    if (!getInstanceRedistributionType().equals(other.getInstanceRedistributionType()))
      return false;
    if (hasMaxSurge() != other.hasMaxSurge()) return false;
    if (hasMaxSurge()) {
      if (!getMaxSurge().equals(other.getMaxSurge())) return false;
    }
    if (hasMaxUnavailable() != other.hasMaxUnavailable()) return false;
    if (hasMaxUnavailable()) {
      if (!getMaxUnavailable().equals(other.getMaxUnavailable())) return false;
    }
    if (!getMinimalAction().equals(other.getMinimalAction())) return false;
    if (!getReplacementMethod().equals(other.getReplacementMethod())) return false;
    if (!getType().equals(other.getType())) return false;
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    hash = (37 * hash) + INSTANCE_REDISTRIBUTION_TYPE_FIELD_NUMBER;
    hash = (53 * hash) + getInstanceRedistributionType().hashCode();
    if (hasMaxSurge()) {
      hash = (37 * hash) + MAX_SURGE_FIELD_NUMBER;
      hash = (53 * hash) + getMaxSurge().hashCode();
    }
    if (hasMaxUnavailable()) {
      hash = (37 * hash) + MAX_UNAVAILABLE_FIELD_NUMBER;
      hash = (53 * hash) + getMaxUnavailable().hashCode();
    }
    hash = (37 * hash) + MINIMAL_ACTION_FIELD_NUMBER;
    hash = (53 * hash) + getMinimalAction().hashCode();
    hash = (37 * hash) + REPLACEMENT_METHOD_FIELD_NUMBER;
    hash = (53 * hash) + getReplacementMethod().hashCode();
    hash = (37 * hash) + TYPE_FIELD_NUMBER;
    hash = (53 * hash) + getType().hashCode();
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy parseFrom(
      java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy parseFrom(
      java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }

  public static com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy parseFrom(
      byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy parseFrom(
      java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy parseFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy parseDelimitedFrom(
      java.io.InputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy parseDelimitedFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(
        PARSER, input, extensionRegistry);
  }

  public static com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy parseFrom(
      com.google.protobuf.CodedInputStream input) throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);
  }

  public static com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(
        PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() {
    return newBuilder();
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }

  public static Builder newBuilder(
      com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   *
   *
   * <pre>
   * </pre>
   *
   * Protobuf type {@code google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy}
   */
  public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder<Builder>
      implements
      // @@protoc_insertion_point(builder_implements:google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy)
      com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicyOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_InstanceGroupManagerUpdatePolicy_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_InstanceGroupManagerUpdatePolicy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.class,
              com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.Builder.class);
    }

    // Construct using com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }

    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {}
    }

    @java.lang.Override
    public Builder clear() {
      super.clear();
      instanceRedistributionType_ = "";

      if (maxSurgeBuilder_ == null) {
        maxSurge_ = null;
      } else {
        maxSurge_ = null;
        maxSurgeBuilder_ = null;
      }
      if (maxUnavailableBuilder_ == null) {
        maxUnavailable_ = null;
      } else {
        maxUnavailable_ = null;
        maxUnavailableBuilder_ = null;
      }
      minimalAction_ = "";

      replacementMethod_ = "";

      type_ = "";

      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
      return com.google.cloud.compute.v1.Compute
          .internal_static_google_cloud_compute_v1_InstanceGroupManagerUpdatePolicy_descriptor;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy
        getDefaultInstanceForType() {
      return com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.getDefaultInstance();
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy build() {
      com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy buildPartial() {
      com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy result =
          new com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy(this);
      result.instanceRedistributionType_ = instanceRedistributionType_;
      if (maxSurgeBuilder_ == null) {
        result.maxSurge_ = maxSurge_;
      } else {
        result.maxSurge_ = maxSurgeBuilder_.build();
      }
      if (maxUnavailableBuilder_ == null) {
        result.maxUnavailable_ = maxUnavailable_;
      } else {
        result.maxUnavailable_ = maxUnavailableBuilder_.build();
      }
      result.minimalAction_ = minimalAction_;
      result.replacementMethod_ = replacementMethod_;
      result.type_ = type_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }

    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.setField(field, value);
    }

    @java.lang.Override
    public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }

    @java.lang.Override
    public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }

    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }

    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }

    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy) {
        return mergeFrom((com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy) other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy other) {
      if (other
          == com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.getDefaultInstance())
        return this;
      if (!other.getInstanceRedistributionType().isEmpty()) {
        instanceRedistributionType_ = other.instanceRedistributionType_;
        onChanged();
      }
      if (other.hasMaxSurge()) {
        mergeMaxSurge(other.getMaxSurge());
      }
      if (other.hasMaxUnavailable()) {
        mergeMaxUnavailable(other.getMaxUnavailable());
      }
      if (!other.getMinimalAction().isEmpty()) {
        minimalAction_ = other.minimalAction_;
        onChanged();
      }
      if (!other.getReplacementMethod().isEmpty()) {
        replacementMethod_ = other.replacementMethod_;
        onChanged();
      }
      if (!other.getType().isEmpty()) {
        type_ = other.type_;
        onChanged();
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage =
            (com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }

    private java.lang.Object instanceRedistributionType_ = "";
    /**
     *
     *
     * <pre>
     * The  instance redistribution policy for regional managed instance groups. Valid values are:
     * - PROACTIVE (default): The group attempts to maintain an even distribution of VM instances across zones in the region.
     * - NONE: For non-autoscaled groups, proactive redistribution is disabled.
     * </pre>
     *
     * <code>string instance_redistribution_type = 24194968;</code>
     *
     * @return The instanceRedistributionType.
     */
    public java.lang.String getInstanceRedistributionType() {
      java.lang.Object ref = instanceRedistributionType_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        instanceRedistributionType_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * The  instance redistribution policy for regional managed instance groups. Valid values are:
     * - PROACTIVE (default): The group attempts to maintain an even distribution of VM instances across zones in the region.
     * - NONE: For non-autoscaled groups, proactive redistribution is disabled.
     * </pre>
     *
     * <code>string instance_redistribution_type = 24194968;</code>
     *
     * @return The bytes for instanceRedistributionType.
     */
    public com.google.protobuf.ByteString getInstanceRedistributionTypeBytes() {
      java.lang.Object ref = instanceRedistributionType_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        instanceRedistributionType_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * The  instance redistribution policy for regional managed instance groups. Valid values are:
     * - PROACTIVE (default): The group attempts to maintain an even distribution of VM instances across zones in the region.
     * - NONE: For non-autoscaled groups, proactive redistribution is disabled.
     * </pre>
     *
     * <code>string instance_redistribution_type = 24194968;</code>
     *
     * @param value The instanceRedistributionType to set.
     * @return This builder for chaining.
     */
    public Builder setInstanceRedistributionType(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }

      instanceRedistributionType_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The  instance redistribution policy for regional managed instance groups. Valid values are:
     * - PROACTIVE (default): The group attempts to maintain an even distribution of VM instances across zones in the region.
     * - NONE: For non-autoscaled groups, proactive redistribution is disabled.
     * </pre>
     *
     * <code>string instance_redistribution_type = 24194968;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearInstanceRedistributionType() {

      instanceRedistributionType_ = getDefaultInstance().getInstanceRedistributionType();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The  instance redistribution policy for regional managed instance groups. Valid values are:
     * - PROACTIVE (default): The group attempts to maintain an even distribution of VM instances across zones in the region.
     * - NONE: For non-autoscaled groups, proactive redistribution is disabled.
     * </pre>
     *
     * <code>string instance_redistribution_type = 24194968;</code>
     *
     * @param value The bytes for instanceRedistributionType to set.
     * @return This builder for chaining.
     */
    public Builder setInstanceRedistributionTypeBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);

      instanceRedistributionType_ = value;
      onChanged();
      return this;
    }

    private com.google.cloud.compute.v1.FixedOrPercent maxSurge_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.FixedOrPercent,
            com.google.cloud.compute.v1.FixedOrPercent.Builder,
            com.google.cloud.compute.v1.FixedOrPercentOrBuilder>
        maxSurgeBuilder_;
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be created above the specified targetSize during the update process. By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxSurge.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_surge = 34137235;</code>
     *
     * @return Whether the maxSurge field is set.
     */
    public boolean hasMaxSurge() {
      return maxSurgeBuilder_ != null || maxSurge_ != null;
    }
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be created above the specified targetSize during the update process. By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxSurge.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_surge = 34137235;</code>
     *
     * @return The maxSurge.
     */
    public com.google.cloud.compute.v1.FixedOrPercent getMaxSurge() {
      if (maxSurgeBuilder_ == null) {
        return maxSurge_ == null
            ? com.google.cloud.compute.v1.FixedOrPercent.getDefaultInstance()
            : maxSurge_;
      } else {
        return maxSurgeBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be created above the specified targetSize during the update process. By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxSurge.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_surge = 34137235;</code>
     */
    public Builder setMaxSurge(com.google.cloud.compute.v1.FixedOrPercent value) {
      if (maxSurgeBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        maxSurge_ = value;
        onChanged();
      } else {
        maxSurgeBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be created above the specified targetSize during the update process. By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxSurge.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_surge = 34137235;</code>
     */
    public Builder setMaxSurge(com.google.cloud.compute.v1.FixedOrPercent.Builder builderForValue) {
      if (maxSurgeBuilder_ == null) {
        maxSurge_ = builderForValue.build();
        onChanged();
      } else {
        maxSurgeBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be created above the specified targetSize during the update process. By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxSurge.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_surge = 34137235;</code>
     */
    public Builder mergeMaxSurge(com.google.cloud.compute.v1.FixedOrPercent value) {
      if (maxSurgeBuilder_ == null) {
        if (maxSurge_ != null) {
          maxSurge_ =
              com.google.cloud.compute.v1.FixedOrPercent.newBuilder(maxSurge_)
                  .mergeFrom(value)
                  .buildPartial();
        } else {
          maxSurge_ = value;
        }
        onChanged();
      } else {
        maxSurgeBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be created above the specified targetSize during the update process. By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxSurge.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_surge = 34137235;</code>
     */
    public Builder clearMaxSurge() {
      if (maxSurgeBuilder_ == null) {
        maxSurge_ = null;
        onChanged();
      } else {
        maxSurge_ = null;
        maxSurgeBuilder_ = null;
      }

      return this;
    }
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be created above the specified targetSize during the update process. By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxSurge.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_surge = 34137235;</code>
     */
    public com.google.cloud.compute.v1.FixedOrPercent.Builder getMaxSurgeBuilder() {

      onChanged();
      return getMaxSurgeFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be created above the specified targetSize during the update process. By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxSurge.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_surge = 34137235;</code>
     */
    public com.google.cloud.compute.v1.FixedOrPercentOrBuilder getMaxSurgeOrBuilder() {
      if (maxSurgeBuilder_ != null) {
        return maxSurgeBuilder_.getMessageOrBuilder();
      } else {
        return maxSurge_ == null
            ? com.google.cloud.compute.v1.FixedOrPercent.getDefaultInstance()
            : maxSurge_;
      }
    }
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be created above the specified targetSize during the update process. By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxSurge.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_surge = 34137235;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.FixedOrPercent,
            com.google.cloud.compute.v1.FixedOrPercent.Builder,
            com.google.cloud.compute.v1.FixedOrPercentOrBuilder>
        getMaxSurgeFieldBuilder() {
      if (maxSurgeBuilder_ == null) {
        maxSurgeBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.cloud.compute.v1.FixedOrPercent,
                com.google.cloud.compute.v1.FixedOrPercent.Builder,
                com.google.cloud.compute.v1.FixedOrPercentOrBuilder>(
                getMaxSurge(), getParentForChildren(), isClean());
        maxSurge_ = null;
      }
      return maxSurgeBuilder_;
    }

    private com.google.cloud.compute.v1.FixedOrPercent maxUnavailable_;
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.FixedOrPercent,
            com.google.cloud.compute.v1.FixedOrPercent.Builder,
            com.google.cloud.compute.v1.FixedOrPercentOrBuilder>
        maxUnavailableBuilder_;
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied:
     * - The instance's status is RUNNING.
     * - If there is a health check on the instance group, the instance's liveness health check result must be HEALTHY at least once. If there is no health check on the group, then the instance only needs to have a status of RUNNING to be considered available.  By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxUnavailable.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_unavailable = 136504821;</code>
     *
     * @return Whether the maxUnavailable field is set.
     */
    public boolean hasMaxUnavailable() {
      return maxUnavailableBuilder_ != null || maxUnavailable_ != null;
    }
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied:
     * - The instance's status is RUNNING.
     * - If there is a health check on the instance group, the instance's liveness health check result must be HEALTHY at least once. If there is no health check on the group, then the instance only needs to have a status of RUNNING to be considered available.  By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxUnavailable.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_unavailable = 136504821;</code>
     *
     * @return The maxUnavailable.
     */
    public com.google.cloud.compute.v1.FixedOrPercent getMaxUnavailable() {
      if (maxUnavailableBuilder_ == null) {
        return maxUnavailable_ == null
            ? com.google.cloud.compute.v1.FixedOrPercent.getDefaultInstance()
            : maxUnavailable_;
      } else {
        return maxUnavailableBuilder_.getMessage();
      }
    }
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied:
     * - The instance's status is RUNNING.
     * - If there is a health check on the instance group, the instance's liveness health check result must be HEALTHY at least once. If there is no health check on the group, then the instance only needs to have a status of RUNNING to be considered available.  By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxUnavailable.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_unavailable = 136504821;</code>
     */
    public Builder setMaxUnavailable(com.google.cloud.compute.v1.FixedOrPercent value) {
      if (maxUnavailableBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        maxUnavailable_ = value;
        onChanged();
      } else {
        maxUnavailableBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied:
     * - The instance's status is RUNNING.
     * - If there is a health check on the instance group, the instance's liveness health check result must be HEALTHY at least once. If there is no health check on the group, then the instance only needs to have a status of RUNNING to be considered available.  By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxUnavailable.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_unavailable = 136504821;</code>
     */
    public Builder setMaxUnavailable(
        com.google.cloud.compute.v1.FixedOrPercent.Builder builderForValue) {
      if (maxUnavailableBuilder_ == null) {
        maxUnavailable_ = builderForValue.build();
        onChanged();
      } else {
        maxUnavailableBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied:
     * - The instance's status is RUNNING.
     * - If there is a health check on the instance group, the instance's liveness health check result must be HEALTHY at least once. If there is no health check on the group, then the instance only needs to have a status of RUNNING to be considered available.  By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxUnavailable.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_unavailable = 136504821;</code>
     */
    public Builder mergeMaxUnavailable(com.google.cloud.compute.v1.FixedOrPercent value) {
      if (maxUnavailableBuilder_ == null) {
        if (maxUnavailable_ != null) {
          maxUnavailable_ =
              com.google.cloud.compute.v1.FixedOrPercent.newBuilder(maxUnavailable_)
                  .mergeFrom(value)
                  .buildPartial();
        } else {
          maxUnavailable_ = value;
        }
        onChanged();
      } else {
        maxUnavailableBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied:
     * - The instance's status is RUNNING.
     * - If there is a health check on the instance group, the instance's liveness health check result must be HEALTHY at least once. If there is no health check on the group, then the instance only needs to have a status of RUNNING to be considered available.  By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxUnavailable.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_unavailable = 136504821;</code>
     */
    public Builder clearMaxUnavailable() {
      if (maxUnavailableBuilder_ == null) {
        maxUnavailable_ = null;
        onChanged();
      } else {
        maxUnavailable_ = null;
        maxUnavailableBuilder_ = null;
      }

      return this;
    }
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied:
     * - The instance's status is RUNNING.
     * - If there is a health check on the instance group, the instance's liveness health check result must be HEALTHY at least once. If there is no health check on the group, then the instance only needs to have a status of RUNNING to be considered available.  By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxUnavailable.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_unavailable = 136504821;</code>
     */
    public com.google.cloud.compute.v1.FixedOrPercent.Builder getMaxUnavailableBuilder() {

      onChanged();
      return getMaxUnavailableFieldBuilder().getBuilder();
    }
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied:
     * - The instance's status is RUNNING.
     * - If there is a health check on the instance group, the instance's liveness health check result must be HEALTHY at least once. If there is no health check on the group, then the instance only needs to have a status of RUNNING to be considered available.  By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxUnavailable.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_unavailable = 136504821;</code>
     */
    public com.google.cloud.compute.v1.FixedOrPercentOrBuilder getMaxUnavailableOrBuilder() {
      if (maxUnavailableBuilder_ != null) {
        return maxUnavailableBuilder_.getMessageOrBuilder();
      } else {
        return maxUnavailable_ == null
            ? com.google.cloud.compute.v1.FixedOrPercent.getDefaultInstance()
            : maxUnavailable_;
      }
    }
    /**
     *
     *
     * <pre>
     * The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied:
     * - The instance's status is RUNNING.
     * - If there is a health check on the instance group, the instance's liveness health check result must be HEALTHY at least once. If there is no health check on the group, then the instance only needs to have a status of RUNNING to be considered available.  By default, a fixed value of 1 is used. This value can be either a fixed number or a percentage if the instance group has 10 or more instances. If you set a percentage, the number of instances will be rounded up if necessary.
     * At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxUnavailable.
     * </pre>
     *
     * <code>.google.cloud.compute.v1.FixedOrPercent max_unavailable = 136504821;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
            com.google.cloud.compute.v1.FixedOrPercent,
            com.google.cloud.compute.v1.FixedOrPercent.Builder,
            com.google.cloud.compute.v1.FixedOrPercentOrBuilder>
        getMaxUnavailableFieldBuilder() {
      if (maxUnavailableBuilder_ == null) {
        maxUnavailableBuilder_ =
            new com.google.protobuf.SingleFieldBuilderV3<
                com.google.cloud.compute.v1.FixedOrPercent,
                com.google.cloud.compute.v1.FixedOrPercent.Builder,
                com.google.cloud.compute.v1.FixedOrPercentOrBuilder>(
                getMaxUnavailable(), getParentForChildren(), isClean());
        maxUnavailable_ = null;
      }
      return maxUnavailableBuilder_;
    }

    private java.lang.Object minimalAction_ = "";
    /**
     *
     *
     * <pre>
     * Minimal action to be taken on an instance. You can specify either RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a RESTART, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
     * </pre>
     *
     * <code>string minimal_action = 2131604;</code>
     *
     * @return The minimalAction.
     */
    public java.lang.String getMinimalAction() {
      java.lang.Object ref = minimalAction_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        minimalAction_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Minimal action to be taken on an instance. You can specify either RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a RESTART, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
     * </pre>
     *
     * <code>string minimal_action = 2131604;</code>
     *
     * @return The bytes for minimalAction.
     */
    public com.google.protobuf.ByteString getMinimalActionBytes() {
      java.lang.Object ref = minimalAction_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        minimalAction_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * Minimal action to be taken on an instance. You can specify either RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a RESTART, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
     * </pre>
     *
     * <code>string minimal_action = 2131604;</code>
     *
     * @param value The minimalAction to set.
     * @return This builder for chaining.
     */
    public Builder setMinimalAction(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }

      minimalAction_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Minimal action to be taken on an instance. You can specify either RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a RESTART, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
     * </pre>
     *
     * <code>string minimal_action = 2131604;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearMinimalAction() {

      minimalAction_ = getDefaultInstance().getMinimalAction();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Minimal action to be taken on an instance. You can specify either RESTART to restart existing instances or REPLACE to delete and create new instances from the target template. If you specify a RESTART, the Updater will attempt to perform that action only. However, if the Updater determines that the minimal action you specify is not enough to perform the update, it might perform a more disruptive action.
     * </pre>
     *
     * <code>string minimal_action = 2131604;</code>
     *
     * @param value The bytes for minimalAction to set.
     * @return This builder for chaining.
     */
    public Builder setMinimalActionBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);

      minimalAction_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object replacementMethod_ = "";
    /**
     *
     *
     * <pre>
     * What action should be used to replace instances. See minimal_action.REPLACE
     * </pre>
     *
     * <code>string replacement_method = 237496238;</code>
     *
     * @return The replacementMethod.
     */
    public java.lang.String getReplacementMethod() {
      java.lang.Object ref = replacementMethod_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        replacementMethod_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * What action should be used to replace instances. See minimal_action.REPLACE
     * </pre>
     *
     * <code>string replacement_method = 237496238;</code>
     *
     * @return The bytes for replacementMethod.
     */
    public com.google.protobuf.ByteString getReplacementMethodBytes() {
      java.lang.Object ref = replacementMethod_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        replacementMethod_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * What action should be used to replace instances. See minimal_action.REPLACE
     * </pre>
     *
     * <code>string replacement_method = 237496238;</code>
     *
     * @param value The replacementMethod to set.
     * @return This builder for chaining.
     */
    public Builder setReplacementMethod(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }

      replacementMethod_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * What action should be used to replace instances. See minimal_action.REPLACE
     * </pre>
     *
     * <code>string replacement_method = 237496238;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearReplacementMethod() {

      replacementMethod_ = getDefaultInstance().getReplacementMethod();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * What action should be used to replace instances. See minimal_action.REPLACE
     * </pre>
     *
     * <code>string replacement_method = 237496238;</code>
     *
     * @param value The bytes for replacementMethod to set.
     * @return This builder for chaining.
     */
    public Builder setReplacementMethodBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);

      replacementMethod_ = value;
      onChanged();
      return this;
    }

    private java.lang.Object type_ = "";
    /**
     *
     *
     * <pre>
     * The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
     * </pre>
     *
     * <code>string type = 3575610;</code>
     *
     * @return The type.
     */
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (!(ref instanceof java.lang.String)) {
        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        type_ = s;
        return s;
      } else {
        return (java.lang.String) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
     * </pre>
     *
     * <code>string type = 3575610;</code>
     *
     * @return The bytes for type.
     */
    public com.google.protobuf.ByteString getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }
    /**
     *
     *
     * <pre>
     * The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
     * </pre>
     *
     * <code>string type = 3575610;</code>
     *
     * @param value The type to set.
     * @return This builder for chaining.
     */
    public Builder setType(java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }

      type_ = value;
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
     * </pre>
     *
     * <code>string type = 3575610;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearType() {

      type_ = getDefaultInstance().getType();
      onChanged();
      return this;
    }
    /**
     *
     *
     * <pre>
     * The type of update process. You can specify either PROACTIVE so that the instance group manager proactively executes actions in order to bring instances to their target versions or OPPORTUNISTIC so that no action is proactively executed but the update will be performed as part of other actions (for example, resizes or recreateInstances calls).
     * </pre>
     *
     * <code>string type = 3575610;</code>
     *
     * @param value The bytes for type to set.
     * @return This builder for chaining.
     */
    public Builder setTypeBytes(com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      checkByteStringIsUtf8(value);

      type_ = value;
      onChanged();
      return this;
    }

    @java.lang.Override
    public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }

    // @@protoc_insertion_point(builder_scope:google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy)
  }

  // @@protoc_insertion_point(class_scope:google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy)
  private static final com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy
      DEFAULT_INSTANCE;

  static {
    DEFAULT_INSTANCE = new com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy();
  }

  public static com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<InstanceGroupManagerUpdatePolicy> PARSER =
      new com.google.protobuf.AbstractParser<InstanceGroupManagerUpdatePolicy>() {
        @java.lang.Override
        public InstanceGroupManagerUpdatePolicy parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new InstanceGroupManagerUpdatePolicy(input, extensionRegistry);
        }
      };

  public static com.google.protobuf.Parser<InstanceGroupManagerUpdatePolicy> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<InstanceGroupManagerUpdatePolicy> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }
}
